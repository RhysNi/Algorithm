# 算法

## 时间复杂度

>一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或「时间频度」。记为T(
n)。时间频度T(n)中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。算法的时间复杂度也就是算法的时间度量，记作：T(n) = O(f(n))
。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称「时间复杂度」。这种表示方法我们称为「 大O符号表示法」，又称为渐进符号，是用于描述函数渐进行为的数学符号

>- 常数时间的操作：固定时间完成操作
> - 常见算术运算（+、-、*、/、%）等
> 

- 常见位运算（>>、>>>、<<、|、&、^）等

> - 赋值、比较、自增、自减操作等
>
> - 数组寻址
> - 非常数时间的操作：LinkedList寻址

### 时间复杂度估算

> - 等差数列求和公式：aN²+bN+c
> - 当N->无穷，常数项可忽略，只看N的最高阶，比如一个算法时间复杂度为O(N³)，另一个算法时间复杂度为O(N²)，两个算法干的是同一件事的情况下 O(N²) 优于 O(N³)

### 常见时间复杂度

> O(1)       O(logN)  O(N)      O(N*logN)
>
> O(N²)     O(N³)       ··· O(N^K)
>
> O(2^N)  O(3^N)      ··· O(k^N)
>
> O(N!)

#### 常数阶O(1)

> `O(1)`，表示该算法的执行时间（或执行时占用空间）总是为一个常量，不论输入的数据集是大是小，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如下代码，在执行的时候，它消耗的时候并`不随着某个变量的增长而增长`
> ，那么无论这类代码有多长，即使有几万几十万行，都可以用`O(1)`来表示它的时间复杂度

```java
int i 1;
int j=2;
int k i+j
```

#### 线性阶O(n)

> `O(n)`，表示一个算法的性能会随着输入数据的大小变化而线性变化，如下代码，for循环里面的代码会执行`n遍`，因此它消耗的时间是`随着n的变化而变化`的，因此这类代码都可以用`O(n)`来表示它的时间复杂度

```java
for(int i=0;i<n;i++)(
  j=i;
  j++;
}
```

#### 平方阶O(n^2)

> `O(n^2)` 表示一个算法的性能将会`随着输入数据的增长而呈现出二次增长`。最常见的就是`对输入数据进行嵌套循环`。如果`嵌套层级不断深入`的话，算法的性能将会变为立方阶`O(n^3)`，`O(n^4)`，`O(n^k)`以此类推

```java
for(x=1;1<=n;x++){
  for(i=1;i<=n;i++)(
    j=i;
    j++;
  }
}
```

#### 立方阶O(n^3)

> 同上

#### 对数阶O(logn)

> 在`while循环`里面，`每次都将 i 乘以 2`，乘完之后，`i 距离 n 就越来越近了，直到i不小于n`退出。我们试着求解一下，假设`循环次数为x，也就是说 2 的 x 次方等于 n`，则由`2^x=n得出x=logn`
> 。因此这个代码的时间复杂度为`O(logn)`

```java
i=1:
while(i<n){
    1=1*2;        
}
```

#### 线性对数阶O(nlogn)

> 线性对数阶`O(nlogn) `，就是将时间复杂度为对数阶`O(logn)`的代码循环n遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了`O(nlogn)`，如下代码

```java
for(int m=1;m<n;m++){
  i=1:
  while(i<n){
    1=1*2;
  }
}
```

#### 指数阶O(2^n)

> `O(2^n)`，表示一个算法的性能会`随着输入数据的每次增加而增大两倍`，典型的方法就是`裴波那契数列的递归计算`实现

```java
int fibonacci(int number){
   if (number <=1){
      return number;
   }
   return fibonacci(number-2)+fibonacci(number-1);
}
```

## 空间复杂度

> 空间复杂度（Space Complexity）是对一个算法在运行过程中`临时占用存储空间大小的一个量度`，同样反映的是一个趋势，一个算法所需的存储空间用f(n)表示。`S(n)=O(f(n))`，其中`n为问题的规模`
> ，`S(n)表示空间复杂度`。一个算法在计算机存储器上所占用的存储空间，包括`存储算法本身所占用的存储空间`，`算法的输入输出数据所占用的存储空间`和`算法在运行过程中临时占用的存储空间`
>
这三个方面。一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间`相对于输入数据量而言是个常数`
> ，则称此算法为`原地工作`，空间复杂度为`O(1)`。当一个算法的空间复杂度与n成线性比例关系时，可表示为`0(n)`，类比时间复杂度。
>
> - 实现一个算法，需要开辟一些空间来支持算法流程
> - 必要的或者和实现目标有关的空间都不算做额外空间
    >

- 作为输入参数的空间

> - 作为输出结果的空间
> - 只需要开辟有限几个变量：额外空间复杂度为O(1)

### 空间复杂度O(1)

> 如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)，如下代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度`S(n) = O(1)`

```java
int i 1;
int j=2;
++i;
j++;
int m i j;
```

### 空间复杂度 O(n)

> 如下代码中，第一行new了一个数组出来，这个数据占用的`大小为n`，这段代码的2-6行，虽然有循环，但`没有再分配新的空间`，因此，这段代码的空间复杂度主要看第一行即可，即 `S(n) = O(n)`

```java
int[] m = new int[n]
for(i=1;i<=n;++i){
  j=i;
  j++;
}
```

## 常见复杂度对比

### 复杂度曲线

​    ![](https://article.biliimg.com/bfs/article/2a9fd7f5a1a99731e5ee52acebff5d92592558693.jpg)

### 抽象数据结构的操作复杂度

​    ![img](https://article.biliimg.com/bfs/article/cf83835522f512cf744e0c51e0be22df592558693.jpg)

### 数组排序复杂度

​    ![img](https://article.biliimg.com/bfs/article/85059f43a412757b5a63f629e2403059592558693.jpg)

### 图操作

​    ![img](https://article.biliimg.com/bfs/article/751aaacdadbfdfab09f87307d7b64b78592558693.jpg)

### 堆操作

​    ![img](https://article.biliimg.com/bfs/article/7cd838d240f290819428d78c55f50290592558693.jpg)

## 常数项

> - 当时间复杂度相同时，通过比常数项来判断算法的优劣
>
> - 常数项对比
    >

- 放弃理论，生成随机数据进行测试（数据量*测试次数 以最终耗费时间做对比 ）

## 最优解

> - 时间复杂度尽可能的低
>
> - 尽可能优化空间

## 公共工具类

```java
package basic;

import java.util.Random;

/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/1 1:57 上午
 * @Description 公共工具类
 */
public class CommonUtils {
    public static final int[] ARR = {1, 4, 6, 2, 7, 2, 9, 8, 1, 0};

    /**
     * 替换数值
     *
     * @param arr 原数组
     * @param i   被替换元素
     * @param j   替换元素
     */
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    /**
     * 打印数组
     *
     * @param arr 数组
     */
    public static void printArray(int[] arr) {
        System.out.print("[");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i]);
            System.out.print(i < arr.length - 1 ? "," : "");
        }
        System.out.print("]\n");
    }

    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    public static int[] buildRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[maxSize];
        for (int i = 0; i < maxSize; i++) {
            arr[i] = new Random().nextInt(maxValue);
        }
        return arr;
    }

    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    private CommonUtils() {
    }
}

```

## 对数器

```java
import java.util.Arrays;

/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/1 3:22 上午
 * @Description 数组排序对数器
 */
public class DataTester {
    public static void main(String[] args) {
        int testCount = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean isSuccess = true;
        for (int i = 0; i < testCount; i++) {
            int[] arr = generateRandomArray(maxSize, maxValue);
            int[] arr1 = copyArray(arr);
            int[] arr2 = copyArray(arr);
            //需要测试的排序方法
            SelectionSort.sort(arr1);
            //用系统自带排序作为对数器和手写的排序方法做对比
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                for (int j = 0; j <arr.length ; j++) {
                    System.out.print(arr[j]+" ");
                }
                System.out.println();
                isSuccess = false;
                break;
            }
        }
        System.out.println(isSuccess?"Nice!":"Fucking fucked!");
    }

    public static int[] generateRandomArray(int maxSize, int maxValue) {
        // Math.random() ->  [0,1) 所有的小数，等概率返回一个
        // Math.random() * N -> [0,N) 所有小数，等概率返回一个
        // (int)(Math.random() * N) -> [0,N-1] 所有的整数，等概率返回一个
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }
}

```

## 异或运算

```java
int a=7;
int b=13;

//a ^ b = ?
//相同为0，不同为1
//a的二进制：0111
//b的二进制：1101
a ^ b = 10;
```

- 异或相加又称无进位相加

- 异或三大性质（技巧）

  > - 0 ^ N = N
  > - N ^ N = 0
  > - 有一批数做异或运算，同时满足交换律和结合律，得到的结果是同一个数
  >   - 偶数个1结果一定是0
  >   - 奇数个1结果一定是1

### 题记

- 两数值交换

  ```java
  int temp = 0;
  temp = a;
  a = b;
  b = temp；
    
  //以上代码可用异或代替
  1、a = a ^ b;
  //第一步：设 a=甲 ，b=乙 得：a = 甲 ^ 乙
  //将a = 甲 ^ 乙带入第二步中
  2、b = a ^ b;
  //第二步：b = 甲 ^ 乙 ^ 乙
  //由N ^ N = 0 （乙^乙=0）得：b = 甲 ^ 0 
  //由0 ^ N = N 得 b = 甲
  //将a = 甲^乙 ，b = 甲带入第二步中
  3、a = a ^ b;
  //第三步：a = 甲^乙^甲 = 甲^甲^乙 = 0^乙 = 乙
  //至此 a = 乙 ， b = 甲，完成了两数的互换
  //注意：此方法只可以用作两个不同区域的
  
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/3 12:47 上午
   * @Description 两值互换
   */
  public class TwoValueExchange {
      public static void main(String[] args) {
          twoValueExchange();
          twoValueExchangeForArray();
      }
  
      /**
       * 不用额外变量交换两个数的值
       */
      public static void twoValueExchange() {
          int a = 10;
          int b = 4;
          a = a ^ b;
          b = a ^ b;
          a = a ^ b;
          System.out.println("a=" + a);
          System.out.println("b=" + b);
      }
  
      /**
       * 不用额外变量交换数组中两个数的值
       */
      public static void twoValueExchangeForArray() {
          int[] arr = {1, 5, 3, 6};
          printArray(arr);
          //交换1、3位置的值
          arr[1] = arr[1] ^ arr[3];
          arr[3] = arr[1] ^ arr[3];
          arr[1] = arr[1] ^ arr[3];
          printArray(arr);
      }
    
     public static void printArray(int[] arr) {
          for (int i = 0; i < arr.length; i++) {
              System.out.print(arr[i] + " ");
          }
          System.out.println();
      }
  }
  ```

- 怎么把一个int类型的数，提取出二进制中最右侧的1来

  ```java
  // 运用 a & (-a) 技巧
  //设：a = 01101110010000
  //第一步：对a取反
  //得：~a = 10010001101111
  //根据 -a = ~a+1
  //得：-a = 10010001110000
  // a & (-a) = 00000000010000
  ```

- 找数

  - 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数？
  - 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数

  ```java
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/2 10:10 下午
   * @Description
   */
  public class EvenTimesOddTimes {
      public static void main(String[] args) {
          findOneKindOddNum();
          findTwoKindsOddNum();
      }
  
      //一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数？
      //利用性质三：
      // 有一批数做异或运算，同时满足交换律和结合律，得到的结果是同一个数
      // 偶数个1结果一定是0
      // 奇数个1结果一定是1
      public static void findOneKindOddNum() {
          int[] arr = {7, 4, 5, 7, 6, 7, 4, 5, 6};
          int exclusiveOr = 0;
          for (int i = 0; i < arr.length; i++) {
              exclusiveOr ^= arr[i];
          }
          // 44  55  66  777
          // 4^4=0   5^5=0   6^6=0   7^7=0  最终三个7消掉两个剩一个7直接返回
          System.out.println(exclusiveOr);
      }
  
      //一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数
      public static void findTwoKindsOddNum() {
          int[] arr = {7, 4, 5, 7, 6, 7, 5, 6};
          int exclusiveOr = 0;
          for (int i = 0; i < arr.length; i++) {
              exclusiveOr ^= arr[i];
          }
          //利用 -a = ~a+1 提取最右边的1
          int oneRight = exclusiveOr & (-exclusiveOr);
          int exclusiveOr2 = 0;
          for (int i = 0; i < arr.length; i++) {
              //4:0100   5:0101  6:0110  7:0111
              //只将最右边为1的数参与异或运算，与运算性质是只有两个位上都是1结果才为1，所以两个数与运算结果!=0的时候必然							 是两种数中的其中一个
              if ((arr[i] & oneRight) != 0) {
                  exclusiveOr2 ^= arr[i];
              }
          }
          //既然已经得到两种数中的其中一种，那么另外一种就直接用 exclusiveOr ^ exclusiveOr2 即可得出
          System.out.println(exclusiveOr2 + " , " + (exclusiveOr ^ exclusiveOr2));
      }
  }
  
  ```

- 一个数组中有一种数出现K次，其他数都出现了M次,已知M > 1，K < M，找到出现了K次的数,要求额外空间复杂度O(1)，时间复杂度O(N)

  ```java
  import java.util.HashMap;
  import java.util.HashSet;
  
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/3 3:08 上午
   * @Description
   */
  public class KM {
      public static void main(String[] args) {
          int kinds = 5;
          //设置需要生成几种数，至少两种数
          int maxValue = 100;
          int testTimes = 100000;
          for (int i = 0; i < testTimes; i++) {
              //-----------------------------------
              //以下代码保证了始终满足k<m条件
              int a = (int) (Math.random() * 9 + 1);
              int b = (int) (Math.random() * 9 + 1);
              int k = Math.min(a, b);
              int m = Math.max(a, b);
              if (k == m) {
                  m++;
              }
              //-----------------------------------
              int numKinds = (int) (Math.random() * kinds) + 2;
              int[] arr = randomArray(numKinds, maxValue, k, m);
              int res1 = test(arr, k);
              int res2 = findKTimesNum(arr, k, m);
              if (res1 != res2) {
                  System.out.println("出错了! " + res2);
              }
          }
          System.out.println("Nice!");
      }
  
      /**
       * 随机生成一个符合题意的数组
       *
       * @param maxValue
       * @param k
       * @param m
       * @return
       */
      public static int[] randomArray(int numKinds, int maxValue, int k, int m) {
          //首先设置一个数往数组里塞k次
          int kNum = randomNum(maxValue);
          //由k , m ，以及生成几种数决定数组长度
          // k+(numKinds-1)*m
          int[] arr = new int[k + (numKinds - 1) * m];
          int i = 0;
          for (; i < k; i++) {
              arr[i] = kNum;
          }
          //第一种数添加完成后减少一种数
          numKinds--;
          //生成的数要不能重复，所以建立hash表来记录已经存在的数
          HashSet<Integer> set = new HashSet<>();
          set.add(kNum);
          while (numKinds != 0) {
              int currNum = 0;
              do {
                  //如果hash表已经存在生成的数就重新生成;
                  currNum = randomNum(maxValue);
              } while (set.contains(currNum));
              set.add(currNum);
              numKinds--;
              //填充m个
              for (int j = 0; j < m; j++) {
                  //接着i的位置往后填充
                  arr[i++] = currNum;
              }
          }
          return upset(arr);
      }
  
  
      /**
       * 将规律的数组打乱
       *
       * @param arr
       * @return
       */
      public static int[] upset(int[] arr) {
          for (int i = 0; i < arr.length; i++) {
              int j = (int) (Math.random() * arr.length);
              int temp = arr[i];
              arr[i] = arr[j];
              arr[j] = temp;
          }
          return arr;
      }
  
      /**
       * 随机生成一个 -num ~ num的数
       *
       * @param range
       * @return
       */
      public static int randomNum(int range) {
          return (int) (Math.random() * range + 1) - (int) (Math.random() * range + 1);
      }
  
  
      /**
       * 寻找出现k次的数
       *
       * @param arr
       * @param m
       * @return
       */
      public static int findKTimesNum(int[] arr, int k, int m) {
          //设k=3;M=5  满足M > 1，K < M
          int[] initArr = new int[32];
          for (int num : arr) {
              for (int j = 0; j < initArr.length; j++) {
                  //&1的含义：j=0 时，num=0011 ，0011 & 1 = 1 initArr[0]+=1 在initArr[0]这个位置上记录一次
                  //j = 1 时，num >> 1 = 0001 ，0001 & 1 = 1 initArr[1]+=1 initArr[1]记录一次
                  //j = 2 时，num >> 2 = 0000 , 0000 & 1 = 0 initArr[1]+=0 相当于initArr[2]位置不记录
                  //以此类推，相当于从最低位到最高位挨个记录对应位置为1的次数
                  initArr[j] += (num >> j) & 1;
              }
          }
  
          //new一个32位int类型变量，遍历记录完各个数出现次数的initArr数组,用每个位上的次数对K和M取模，结果为1的说明这个        					 数在第i位上为1
          //逐位往new的变量里面设置值，最终得到一个数
          int result = 0;
          for (int i = 0; i < initArr.length; i++) {
              if (initArr[i] % m != 0) {
                  //在第几位上有1就将result的第几位设置成1
                  // 如：第2位上有1时 1(0001)<<2 = 0100 ；0100 | result(0000) = 0100
                  //    第3位上有1时 1(0001)<<3 = 1000 ；1000 | result(0100) = 1100
                  // 得到最终result为1100 (此结果为举例结果，非题解)
                  result |= (1 << i);
              }
          }
          return result;
      }
  
      /**
       * 对数器遍历计数法 百分百正确的结果
       *
       * @param arr
       * @param k
       * @return
       */
      public static int test(int[] arr, int k) {
          HashMap<Integer, Integer> map = new HashMap<>();
          for (int num : arr) {
              if (map.containsKey(num)) {
                  map.put(num, map.get(num) + 1);
              } else {
                  map.put(num, 1);
              }
          }
          for (int num : map.keySet()) {
              if (map.get(num) == k) {
                  return num;
              }
          }
          return -1;
      }
  }
  ```
  
- 一个数组中有一种数出现K次，其他数都出现了M次,已知M > 1，K < M，找到出现了K次的数,并且当这个数没有出现K次的时候返回-1要求额外空间复杂度O(1)，时间复杂度O(N)

  ```java
  //findKTimesNum方法改写
  public static int findKTimesNum(int[] arr, int k, int m) {
    //设k=3;M=5  满足M > 1，K < M
    int[] initArr = new int[32];
    for (int num : arr) {
      for (int j = 0; j < initArr.length; j++) {
        //&1的含义：j=0 时，num=0011 ，0011 & 1 = 1 initArr[0]+=1 在initArr[0]这个位置上记录一次
        //j = 1 时，num >> 1 = 0001 ，0001 & 1 = 1 initArr[1]+=1 initArr[1]记录一次
        //j = 2 时，num >> 2 = 0000 , 0000 & 1 = 0 initArr[1]+=0 相当于initArr[2]位置不记录
        //以此类推，相当于从最低位到最高位挨个记录对应位置为1的次数
        initArr[j] += (num >> j) & 1;
      }
    }
  
    //new一个32位int类型变量，遍历记录完各个数出现次数的initArr数组,用每个位上的次数对K和M取模，结果为1的说明这个数在第i位上为1
    //逐位往new的变量里面设置值，最终得到一个数
    int result = 0;
    for (int i = 0; i < initArr.length; i++) {
      if (initArr[i] % m == 0) {
        continue;
      }
      if (initArr[i] % m == k) {
        result |= (1 << i);
      } else {
        result = -1;
      }
    }
  
    //解决0没有出现k次的情况
    if (result==0){
      int count = 0;
      for (int num:arr) {
        if (num==0){
          count++;
        }
      }
      if (count!=k){
        return -1;
      }
    }
    return result;
  }
  
  
  
  //randomArray方法改写
  public static int[] randomArray(int numKinds, int maxValue, int k, int m) {
    //首先设置一个数往数组里塞k次
    int kNum = randomNum(maxValue);
  
    //使生成k次的几率为50%，50%几率随机生成一个比m小的数;
    int times = Math.random()<0.5?k: (int) ((Math.random() * (m - 1)) + 1);
    int[] arr = new int[times + (numKinds - 1) * m];
    int i = 0;
    for (; i < times; i++) {
      arr[i] = kNum;
    }
  
    //第一种数添加完成后减少一种数
    numKinds--;
    //生成的数要不能重复，所以建立hash表来记录已经存在的数
    HashSet<Integer> set = new HashSet<>();
    set.add(kNum);
    while (numKinds != 0) {
      int currNum = 0;
      do {
        //如果hash表已经存在生成的数就重新生成;
        currNum = randomNum(maxValue);
      } while (set.contains(currNum));
      set.add(currNum);
      numKinds--;
      //填充m个
      for (int j = 0; j < m; j++) {
        //接着i的位置往后填充
        arr[i++] = currNum;
      }
    }
    return upset(arr);
  }
  
  
  //对数器改写
  public static void main(String[] args) {
    int kinds = 5;
    //设置需要生成几种数，至少两种数
    int maxValue = 100;
    int testTimes= 100000;
  
    for (int i = 0; i < testTimes; i++) {
      //-----------------------------------
      //以下代码保证了始终满足k<m条件
      int a = (int) (Math.random() * 9 + 1);
      int b = (int) (Math.random() * 9 + 1);
      int k = Math.min(a, b);
      int m = Math.max(a, b);
      if (k == m) {
        m++;
      }
      //-----------------------------------
      int numKinds = (int) (Math.random() * kinds) + 2;
      int[] arr = randomArray(numKinds, maxValue, k, m);
      int res1 = test(arr, k);
      int res2 = findKTimesNum(arr, k, m);
  
      if (res1 != res2) {
        System.out.println("出错了! "+res1 +" "+ res2);
      }
    }
    System.out.println("Nice!");
  }
  ```
  
  

## 基础数据结构

### 链表

#### 单向链表

#### ![image-20211208204231073](https://article.biliimg.com/bfs/article/08baf2536d0f6968794ae77f742f6cf7dbe22392.png)

##### 节点结构

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/5 9:59 上午
 * @Description 单向链表节点结构
 */
public class Node<T> {
    public T value;
    public Node<T> next;

    public Node(T value) {
        this.value = value;
    }
}
```

##### 题记

###### 单链表反转

- 思路图解

###### ![image-20211213030503316](https://article.biliimg.com/bfs/article/1ee4c9b56b024a4315b7d5a1b1f143d5ae7043dd.png)

- 关键代码

  ```java
  //a -> b -> c -> null
  //null <- a <- b <- c
  public static Node reverse(Node head) {
    Node pre = null;
    Node next = null;
    while (head != null) {
      //提前记录next节点
      next = head.next;
      //将头结点的下一个节点指向Pre
      head.next = pre;
      //pre移动到当前头节点位置
      pre=head;
      //头结点移动到提前记录的next位置
      head=next;
    }
    //当head为null时说明已经到头了,此时应该返回pre所在位置的节点作为头结点
    return pre;
  }
  ```
  
  

####  

#### 双向链表

#### <img src="https://article.biliimg.com/bfs/article/a88061a87d775db4ac693b7d9fe5a6372249e6c6.png" alt="image-20211208203724483" style="zoom:100%;" />

##### 节点结构

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/5 10:35 上午
 * @Description
 */
public class DoubleNode<T> {
    public T value;
    public DoubleNode<T> pre;
    public DoubleNode<T> next;

    public DoubleNode(T value) {
        this.value = value;
    }
}
```

##### 题记

###### 双向链表反转 

- 思路图解

  ![image-20211213030331079](https://article.biliimg.com/bfs/article/e23d0a0e8b486d8e65a38d102dedd72d4165a9b3.png)

- 关键代码

  ```java
  public static DoubleNode<Integer> reverse(DoubleNode<Integer> head) {
    DoubleNode<Integer> pre = null;
    DoubleNode<Integer> next = null;
    while (head != null) {
  		//首先记录next节点
      next = head.next;
      //将当前头节点的下一个节点指向当前pre所在的地址
      head.next = pre;
      //将当前头结点的上一个节点指向原来next的地址
      head.last = next;
      //将pre标志移动到当前头的位置
      pre = head;
      //将next变为头结点
      head = next;
    }
    //当头结点到达Null的时候说明pre是最后一个有效头节点
    return pre;
  }
  ```

###### K个节点的组内逆序调整

>   - 给定一个单链表的头节点head，和一个正数k，实现k个节点的小组内部逆序，如果最后一组不够k个就不调整
>
>     - 例子: 调整前：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8，k = 3
>
>       ​		  调整后：3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8

- 思路图解

  ![image-20211218212040853](https://article.biliimg.com/bfs/article/b25bfcc2c554827e34406b9fcc3c45aebaa3eebb.png)

- 关键代码

  ```java
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/16 8:34 下午
   * @Description Definition for singly-linked list.
   * public class ListNode {
   * int val;
   * ListNode next;
   * ListNode() {}
   * ListNode(int val) { this.val = val; }
   * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
   * }
   * 力扣原题：https://leetcode-cn.com/problems/reverse-nodes-in-k-group/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china
   */
  public class ReverseKGroup<T> {
      public ListNode reverseKGroup(ListNode head, int k) {
          ListNode start = head;
          ListNode groupEnd = findGroupEnd(start, k);
          //凑不够一组直接返回当前头节点
          if (groupEnd == null) {
              return head;
          }
          //第一组满足K个
          head = groupEnd;
          reverse(start, groupEnd);
          //上一组的最后一个节点（其实就是上一组的开始节点，经过反转后成为最后一个节点）
          ListNode lastEnd = start;
          //当上一组的最后一个节点不指向Null的时候（如果最后没凑够一组也是会返回Null的）
          while (lastEnd.next != null) {
              //将上一组最后一个节点的下一个节点设置为下一组的开始节点
              start = lastEnd.next;
              groupEnd = findGroupEnd(start, k);
              if (groupEnd == null) {
                  return head;
              }
              reverse(start, groupEnd);
              //上一组反转后的最后一个节点指向这一组的结束节点
              lastEnd.next = groupEnd;
              //将下一组的开始节点设置为反转后的最后一个节点
              lastEnd = start;
          }
          return head;
      }
  
      /**
       * 组内反转
       *
       * @param start
       * @param groupEnd
       * @return
       */
      public void reverse(ListNode start, ListNode groupEnd) {
          ListNode pre = null;
          ListNode curr = start;
          //代名词为：本组反转操作的最后标志位，实际为下一组的开始节点
          ListNode operationEnd = groupEnd.next;
          //如果Curr标志位跳到操作终止节点代表本组反转已经结束
          while (curr != operationEnd) {
              ListNode next = curr.next;
              curr.next = pre;
              pre = curr;
              curr = next;
          }
          //本组的开始节点(反转后应该是最后一个节点)，指向下一组的开始节点
          start.next = operationEnd;
      }
  
      /**
       * 找每组最后一个节点
       *
       * @param start
       * @param k
       * @return
       */
      public ListNode findGroupEnd(ListNode start, int k) {
          while (--k != 0 && start != null) {
              start = start.next;
          }
          return start;
      }
  
  
      public class ListNode {
          int val;
          ListNode next;
  
          ListNode() {
          }
  
          ListNode(int val) {
              this.val = val;
          }
  
          ListNode(int val, ListNode next) {
              this.val = val;
              this.next = next;
          }
      }
  }
  
  ```

###### 两个链表相加

> 给定两个链表的头节点head1和head2，认为从左到右是某个数字从低位到高位，返回相加之后的链表
>
> - 例子     4 -> 3 -> 6 -> 9        3 -> 5 -> 4
>
>   返回     7 -> 8 -> 0 -> 0 -> 1
>
>   解释     9634 + 453 = 10087

- 思路图解

  ![image-20211222014356479](https://article.biliimg.com/bfs/article/5b19316cbcdba92f65e5efb6e31161a07a519276.png)

- 关键代码

  ```java
  //长短链表题
  //共分为三阶段：
  //一阶段：长链表有，短链表有
  //二阶段：长链表有，短链表无
  //三阶段：长链表无，短链表无
  
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/20 10:57 下午
   * @Description 两链表相加
   * @leetcode：https://leetcode.com/problems/add-two-numbers/
   */
  public class AddTwoNumbers {
      public ListNode addTwoNumbers(ListNode head1, ListNode head2) {
          int len1 = calcLength(head1);
          int len2 = calcLength(head2);
          ListNode longNode = len1 >= len2 ? head1 : head2;
          ListNode shortNode = longNode == head1 ? head2 : head1;
          ListNode currL = longNode;
          ListNode currS = shortNode;
          ListNode last = null;
          int carry = 0;
          int nodeSum = 0;
          //一阶段：长短链表都有的情况 直接判断短链表是否为NULL得知是否一阶段结束
          while (currS != null) {
              nodeSum = currL.val + currS.val + carry;
              currL.val = nodeSum % 10;
              carry = nodeSum / 10;
              last = currL;
              currL = currL.next;
              currS = currS.next;
          }
  
          //二阶段，长链表有，短链表无
          while (currL != null) {
              nodeSum = currL.val + carry;
              currL.val = nodeSum % 10;
              carry = nodeSum / 10;
              last = currL;
              currL = currL.next;
          }
  
          //三阶段：长短链表都无，校验进位信息决定是否补新节点
          if (carry != 0) {
              last.next = new ListNode(1);
          }
          return null;
      }
  
      /**
       * 计算链表长度
       *
       * @param node
       * @return
       */
      public int calcLength(ListNode node) {
          int length = 0;
          while (node != null) {
              length++;
              node = node.next;
          }
          return length;
      }
  
      public class ListNode {
          int val;
          ListNode next;
  
          ListNode() {
          }
  
          ListNode(int val) {
              this.val = val;
          }
  
          ListNode(int val, ListNode next) {
              this.val = val;
              this.next = next;
          }
      }
  }
  ```

  

###### 两个有序链表的合并

- 思路图解

  ![image-20211225114944761](https://article.biliimg.com/bfs/article/0e3a7282524d7bfa792a1fddd0188cbc1e6af2db.png)

- 关键代码

  ```java
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/22 8:35 下午
   * @Description 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
   * @leetcode：https://leetcode-cn.com/problems/merge-two-sorted-lists/
   */
  public class MergeTwoLists {
      public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
          if (list1 == null || list2 == null) {
              return list1 == null ? list2 : list1;
          }
  
          //找到最小的作为头节点（升序链表）
          ListNode head = list1.val <= list2.val ? list1 : list2;
          ListNode pre = head;
          ListNode curr1 = head.next;
          ListNode curr2 = head == list1 ? list2 : list1;
          //两链表都有节点
          while (curr1 != null && curr2 != null) {
              if (curr1.val <= curr2.val) {
                  pre.next = curr1;
                  curr1 = curr1.next;
              } else {
                  pre.next = curr2;
                  curr2 = curr2.next;
              }
              pre = pre.next;
          }
          //仅剩一个链表有节点
          pre.next = curr1 == null ? curr2 : curr1;
          return head;
      }
  
  
      public class ListNode {
          int val;
          ListNode next;
  
          ListNode() {
          }
  
          ListNode(int val) {
              this.val = val;
          }
  
          ListNode(int val, ListNode next) {
              this.val = val;
              this.next = next;
          }
      }
  }
  ```
  
  

## 栈

- 数据先进后出（子弹匣）

### 手写栈

### ![image-20211209030917929](https://article.biliimg.com/bfs/article/e7d844430f30781b705dffb116a1db29e570d16c.png)

#### 单链表实现

##### 思路图解

![image-20211213030758613](https://article.biliimg.com/bfs/article/1abca091465ab701f3a2244758b35846997aa956.png)

##### 关键代码

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/9 2:45 上午
 * @Description
 */
public class MyStack<T> {
    private Node<T> head;
    private int size;

    public int size() {
        return this.size;
    }

    public Boolean isEmpty() {
        return size == 0;
    }

    /**
     * 压栈
     * @param value
     */
    public void push(T value) {
        //遵循队列先进后出
        //从头节点开始弹出，符合队列先进后出机制
        Node<T> currNode = new Node<>(value);
        if (head != null) {
            currNode.next = head;
        }
        head = currNode;
        size++;
    }

    /**
     * 弹栈
     * @return
     */
    public T pop() {
        T val = null;
        if (head != null) {
            val = head.value;
            head = head.next;
            size--;
        }
        return val;
    }

    /**
     * 查看栈顶值
     * @return
     */
    public T peek() {
        return head == null ? null : head.value;
    }
}

```

- 双向链表实现

  ```java
  
  ```

- 数组实现

  ```java
  
  ```

### 题记

- 实现一个特殊的栈，在基本工能的基础上，再实现返回栈中最小元素的功能

  - pop、push、getMin操作的时间复杂度都是O(1)
  - 设计的栈类型可以使用现成的栈结构

  ```java
  //建两个栈，一个数据栈，一个最小值栈，每往数据栈里压一个值，同步往最小值栈里压一个值
  //最小值呀栈的情况为：当最小值栈为空的时候，同步压数据栈相同的数，当最小值栈里有内容的时候
  //数据栈当前压栈的值跟最小值栈里栈顶的值比较，如果比最小值栈顶值小就同步压入当前数据栈栈顶的值，
  //如果比最小值栈顶大就重复压入当前最小值栈顶的值
  ```

  



## 队列

- 数据先进先出（排队）

### 手写队列

#### 主要功能

![image-20211209030950177](https://article.biliimg.com/bfs/article/f65975718a6258df3b5fb7be7b62c80e04fcf2ee.png)

#### 单链表实现

##### 思路图解

![image-20211213221518395](https://article.biliimg.com/bfs/article/fcf407dccaab1c1a44ad1ae10c288bab45117888.png)

##### 关键代码

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/9 12:05 上午
 * @Description
 */
public class MyQueue<T> {
    private Node<T> head;
    private Node<T> tail;
    private int size;


    public int size() {
        return this.size;
    }

    public Boolean isEmpty() {
        return size == 0;
    }

    public void offer(T value) {
        //遵循队列先进先出
        //从头节点开始弹出，符合队列先进先出机制
        Node<T> currNode = new Node<>(value);
        if (tail == null) {
            head = currNode;
            tail = currNode;
        } else {
            tail.next = currNode;
            tail = currNode;
        }
        size++;
    }

    public T poll() {
        T value = null;
        if (head != null) {
            //获取当前头结点的值
            value = head.value;
            //让当前头节点的下一个节点成为新的头节点
            head = head.next;
            //每弹出一个值size同步递减
            size--;
        }
        if (head==null){
            //说明没有值了，保持头尾节点一致;
            tail = null;
        }
        return value;
    }

    public T peek() {
        T value = null;
        if (head != null) {
            //获取当前头结点的值
            value = head.value;
        }
        return value;
    }

    public MyQueue() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
}
```

### 手写双端队列

#### 主要功能

![image-20211213025804017](https://article.biliimg.com/bfs/article/b6799f424256ea185506b76f1b68b8f8f8eb6da1.png)

#### 思路图解

![image-20211213221552527](https://article.biliimg.com/bfs/article/68f719bd6947787938aca4b0017366070db8302f.png)

#### 关键代码

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/13 1:34 上午
 * @Description
 */
public class MyDeque<T> {
    private DoubleNode<T> head;
    private DoubleNode<T> tail;
    private int size;

    public void pushHead(T value) {
        DoubleNode<T> curr = new DoubleNode<>(value);
        if (head == null) {
            head = curr;
            tail = curr;
        } else {
            head.last = curr;
            curr.next = head;
            head = curr;
        }
        size++;
    }

    public void pushTail(T value) {
        DoubleNode<T> curr = new DoubleNode<>(value);
        if (head == null) {
            head = curr;
            tail = curr;
        } else {
            tail.next = curr;
            curr.last = tail;
            tail = curr;
        }
        size++;
    }

    public T pollHead() {
        T value = null;
        if (head == null) {
            return value;
        }
        value = head.value;
        if (head == tail) {
            head = null;
            tail = null;
        } else {
            head = head.next;
            head.last = null;
        }
        size--;
        return value;
    }

    public T pollTail() {
        T value = null;
        if (tail == null) {
            return value;
        }
        value = tail.value;
        if (tail == head) {
            tail = null;
            head = null;
        } else {
            tail = tail.last;
            tail.next = null;
        }
        size--;
        return value;
    }

    public T peekHead() {
        T value = null;
        if (!isEmpty()) {
            value = head.value;
        }
        return value;
    }

    public T peekTail() {
        T value = null;
        if (!isEmpty()) {
            value = tail.value;
        }
        return value;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return size;
    }

    public MyDeque() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
}

```

### 题记

- 如何用栈结构实现队列结构

  ```java
  //由于栈先进后出，队列先进先出，所以需要两个栈来拼出一个队列，先压满第一个栈，然后逐个弹栈往第二个栈里压，压完第二个栈就相当于出栈顺序跟队列保持一致了，相当于将第一个栈里的数据进行了一个反转
  //push栈没倒完数据。pop栈不能取数据
  //pop栈没取完，push栈不能倒数据
  ```

- 如何用队列结构实现栈结构

  ```java
  //由于队列先进先出 栈先进后出，每次像栈那样去取最顶（后）的值，所以建两个队列，要去1队列的最后进入的值时，把这个值前面的所有值全部pop到队列2，如果要在队列2取新进入的值，则将队列2要取的值前面所有值重新pop到队列1，只留要取的那个值，这样来回pop 就可以想栈那样push想要的值 
  ```

## 递归

- 任何递归都可以转换为非递归 

### 系统栈

```java


```

### Master公式

- 形如 T(N) = a*T(N/b)+O(N^d) 其中的a、b、d都是常数的递归函数，可以直接通过Master公式来确定时间复杂度

  1、如果log(b,a) < d,复杂度为O(N^d)

  2、如果log(b,a) > d,复杂度为O(N^log(b,a))

  3、如果log(b,a) ==d,复杂度为O(N^d*logN)

  ```java
  T(N) = 2*T(N/2)+O(N); 
  a=2,b=2,d=1; log(2,2)=1==d; 
  满足log(b,a)==d,复杂度为O(N^d*logN)
  ```

- 不属于T(N) = a*T(N/b)+O(N^d) 其中的a、b、d都是常数的递归函数这种形式的复杂度计算

  ```java
  递归取最大值时先取左边2/3再取右边2/3，这种情况下就是有一部分是重合的
  此时T(N) = 2*T(N/3/2)+O(1);
  a=2,b=3/2,d=0
  复杂度为 O(N^log(3/2,2))
  ```

## Hash表(HashMap)

- 基础类型和非基础类型底层的区别
  - 基础类型根据实际情况开辟具体空间进行存储，哪怕需要开辟的空间非常大
  - 非基础类型会将引用的类型的内存地址，8字节     
- Hash表中的原生基础类型都是按值传递 (其中包括String类型)，如果是自定义的类型（非原生自带的）按引用传递

## 有序表(TreeMap)

- 有序表可用（红黑树、avl树，sb树、跳表）实现

- Java中TreeMap使用红黑树实现

- 时间复杂度为O(logN)

-  有序表比Hash表多且强大的功能

  ```java
  TreeMap<Integer,String> treeMap = new TreeMap<>();
  //最小key
  System.out.println(treeMap.firstKey());
  //最大key
  System.out.println(treeMap.lastKey());
  //<=4 查找离4最近的key
  System.out.println(treeMap.floorKey(4));
  //>=4 查找离4最近的key
  System.out.println(treeMap.ceilingKey(4));
  ```

- 有序表对非基础类型进行排序时需要自己传一个比较器定义排序规则

## 归并排序

> MergeSort：时间复杂度为O(N*logN)，时间复杂度计算如下：
>
> **假设有一个函数`f(arr,left,right)`,让这个`arr`在`left,right`区间上有序，我们要做一下几步事情**
>
> （1）先找到中点`mid`
>
> （2）让`f(arr,left,mid)`有序
>
> （3）让`f(arr,mid+1,right)`有序
>
> （4）将`f(arr,left,mid)`和`f(arr,mid+1,right)`进行`merge`
>
> 根据Master公式`T(N) = a*T(N/b)+O(N^d) `，`a`的值取决于递归操作的数量，这里面我们需要对左右两个区间分别进行递归排序因此`a=2`、`b`则对应`（2）和（3）`，因此`b=2`,那么`O(N^d)`则对应`merge`的复杂度，`merge`为`O(N)`,最终得`T(N) = a*T(N/2)+O(N)`，由`log(b,a) ==d,`得`log(2,2)=1==d，因此复杂度为O(N*logN)`

### 归并逻辑

```java

/**
 * <p>
 * <b>归并排序</b>
 * </p >
 *
 * @author : RhysNi
 * @version : v1.0
 * @date : 2023/9/18 15:28
 * @CopyRight :　<a href="https://blog.csdn.net/weixin_44977377?type=blog">倪倪N</a>
 */
public class MergeSortMain {
    public static void main(String[] args) {
        int testTime = 500_000;
        int maxSize = 100;
        int maxValue = 100;

        System.out.println("--- MergeSort test start ---");
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = CommonUtils.buildRandomArray(maxSize, maxValue);
            int[] arr2 = CommonUtils.copyArray(arr1);

            // 递归法
            MergeSortByRecursion.mergeSort(arr1);
            // 步长法
            MergeSortNonRecursion.mergeSort(arr2);

            if (!CommonUtils.isEqual(arr1, arr2)) {
                System.out.println("MergeSort test error");
                printArray(arr1);
                printArray(arr2);
            }
        }
        System.out.println("--- MergeSort test success ---");
    }


    public static void merge(int[] arr, int startIndex, int mid, int endIndex) {
        // 辅助数组用于最终合并数据，长度为起始索引到结束索引的所有元素的个数
        int[] tempArr = new int[endIndex - startIndex + 1];
        int i = 0;
        int startIndexL = startIndex;
        int startIndexR = mid + 1;

        // 越界判断，保证左右两部分都没有越界
        while (startIndexL <= mid && startIndexR <= endIndex) {
            // 通过指针移动使左右两边的元素一一比较，哪边小就取那边，相等则默认取左边（实际取哪边都一样）
            tempArr[i++] = arr[startIndexL] <= arr[startIndexR] ? arr[startIndexL++] : arr[startIndexR++];
        }

        //当左边越界,右边没越界时，放入右组元素
        while (startIndexR <= endIndex) {
            tempArr[i++] = arr[startIndexR++];
        }
        //当右边越界，左边没越界时，放入左组元素
        while (startIndexL <= mid) {
            tempArr[i++] = arr[startIndexL++];
        }

        // 将最终排序完成的数组传递给原数组
        for (int j = 0; j < tempArr.length; j++) {
            // 从最新的起始索引开始往后
            arr[startIndex + j] = tempArr[j];
        }
    }
}
```

### 递归写法

```java
/**
 * <p>
 * <b>递归写法</b>
 * </p >
 *
 * @author : RhysNi
 * @version : v1.0
 * @date : 2023/9/18 20:10
 * @CopyRight :　<a href="https://blog.csdn.net/weixin_44977377?type=blog">倪倪N</a>
 */
public class MergeSortByRecursion {
  public static void mergeSort(int[] arr) {
    if (arr == null || arr.length < 2) {
      return;
    }
    // 对数从第一个元素到最后一个元素进行归并排序
    process(arr, 0, arr.length - 1);
  }

  private static void process(int[] arr, int startIndex, int endIndex) {
    // 开始到结束只存在一个数，默认有序，直接返回
    if (startIndex == endIndex) {
      return;
    }

    // 开始到结束存在多个元素的取中点，先对左边递归排序，再对右边递归排序，最终进行合并
    // 如果 数组长度为15，起始索引从0开始。对应最大索引为arr[14], 14>>1 = 1110 >> 1 = 0111 = 7
    // 如果 数组长度为16，起始索引从0开始。对应最大索引为arr[15], 15>>1 = 1111 >> 1 = 0111 = 7
    int mid = startIndex + ((endIndex - startIndex) >> 1);
    // 作用相同，但上面写法更安全，因为如果数组长度非常大，startIndex + endIndex 可能越界
    // int mid = (startIndex + endIndex) / 2;

    // 递归开始直到完全排序完成
    process(arr, startIndex, mid);
    process(arr, mid + 1, endIndex);
    MergeSortMain.merge(arr, startIndex, mid, endIndex);
  }
}

```

### 迭代写法

```java
/**
 * <p>
 * <b>非递归写法-计算步长</b>
 * </p >
 *
 * @author : RhysNi
 * @version : v1.0
 * @date : 2023/9/18 20:11
 * @CopyRight :　<a href="https://blog.csdn.net/weixin_44977377?type=blog">倪倪N</a>
 */
public class MergeSortNonRecursion {
  public static void mergeSort(int[] arr) {
    if (arr == null || arr.length < 2) {
      return;
    }

    // 定义一个步长，根据步长的变化控制每次参与排序的元素数量
    // 假设又数组[8，1，7，6，2]
    // step = 1 --- 则每次只有1个元素为一组参与排序，即 [8] vs [1] -- [7]vs [6] -- [2] -- 得[1,8,6,7,2]
    // step = 2 --- 则每次有2个元素为一组参与排序，即 [1,8] vs [6,7] -- [9] -- 得[1,6,7,8,2]
    // step = 4 --- 则每次有4个元素为一组参与排序，如果有凑不足4个元素为一组的就直接参与merge, 即 [1,6,7,8] vs [2] -- 得[1,2,6,7,8]
    int step = 1;

    // 最大边界为数组长度
    int endIndex = arr.length;

    // 边界判断 :
    // 有这么一种情况，假设数组最大长度是15
    // 当 step = 8 时候，左右两组得元素索引都还在边界范围内
    // 当 step = 16 时。已经比原数组长度大了。当获取arr[15]的时候就越界了，我们最大数组长度是15，对应的最大索引即为arr[14]
    // 还有一种情况 ，假设数组最大长度是16
    // 当 step = 8 时候，左右两组得元素索引都还在边界范围内
    // 当 step = 16 时, 步长和数组最大长度相等时则不用进行排序了，说明该排序的都已经排好了，右组没有多余的元素需要进行排序了。
    // 所以如果步长*2 >= 边界最大长度直接结束了
    while (step < endIndex) {
      // 左组起始索引从0开始
      int startIndexL = 0;
      while (startIndexL < endIndex) {
        // 初始化中位索引
        int midIndex = 0;
        // 确定左组边界
        if (endIndex - startIndexL >= step) {
          // 当边界索引-左组起始索引 >= 步长时:
          // 代表左组能够凑到步长数对应的元素个数或者刚好和步长相等,则可定中位索引为：左组起始索引+步长数-1
          // 假设数组长度为15：endIndex=15 -- startIndexL=0 -- step=8 -- 得endIndex-startIndexL=15 -- 因此midIndex=0+8-1=arr[7]
          // 假设数组长度为16：endIndex=16 -- startIndexL=0 -- step=16 -- 得endIndex-startIndexL=16 -- 因此midIndex=0+16-1=arr[15]
          midIndex = startIndexL + step - 1;
        } else {
          // 假设数组长度为15：endIndex=15 -- startIndexL=0 -- step=16 -- 得endIndex-startIndexL=15 -- 因此midIndex=0+16-1=arr[15]
          // 但是我们数组最大长度为15，对应的最大索引应该是arr[14]，只有15个数，凑不够16个数为一组
          // 如果使用arr[15]则会发生越界，因此我们定义midIndex为最大索引即可，有多少算多少
          midIndex = endIndex - 1;
        }

        // 如果左组长度刚好为整个数组的长度，说明该排序的都排好了，没有右组则无需排序
        if (midIndex == endIndex - 1) {
          break;
        }

        // 有右组的情况下先确定右组边界
        // 初始化右组边界
        int endIndexR = 0;
        // 因为刚才我们确定了midIndex的位置：在 startIndexL + step - 1位置上
        // - 假设数组长度为16 -- step=8：midIndex=在startIndexL + step - 1位置上=arr[7] -- endIndex - 1 - midIndex = 15-7=8
        //   因此刚好凑够一组与步长相等个数的元素，则右组边界定为中位索引+步长的值
        if (endIndex - 1 - midIndex >= step) {
          endIndexR = midIndex + step;
        } else {
          // - 假设数组长度为15 -- step=8：midIndex在startIndexL + step - 1位置上=arr[7] -- endIndex-1-midIndex = 14-7=7
          //   因此凑不够8个元素的右组，直接以最大索引作为右组最大边界
          endIndexR = endIndex - 1;
        }

        // 提供排序数组，左组开始索引，中位索引，和右组边界索引进行归并排序
        MergeSortMain.merge(arr, startIndexL, midIndex, endIndexR);

        // 如果上一组的右组边界刚好等于数组最大索引则无需继续排序
        // 如果仍然存在其他元素可进行排序，则需要将指针移动到下一组的左组起始索引位置,即endIndexR + 1的位置
        if (endIndexR == endIndex - 1) {
          break;
        } else {
          startIndexL = endIndexR + 1;
        }
      }
      // 控制步长为 2^N并且当步长 > 数组一半长度时不用继续增加步长
      // 假设数组长度15 ， endIndex / 2 = 7
      // 因此当 step=1 时候 下一次排序则需要将步长调整为 step=2...直到step=8时，此时步长超过中位索引长度，意味着本次排序完成将没有多余元素参与排序
      // 如果将步长调整为16 即step=16时，已经超过数组最大长度
      // 同理：步长==中位索引长度也是一样不需要继续调整步长
      if (step > endIndex / 2) {
        break;
      } else {
        step *= 2;
      }
    }
  }
}
```

### 面试题拓展

#### 小和问题

> 给定一个数组，例如[3,5,6,3,7,8,9,2],求每个元素左侧小于当前元素的总和，要求时间复杂度`O(N*logN)`

##### 非递归实现

> -  当前数指针在`index[0]`时，`3`左侧没有比本身小的元素，故和为`0`
>- 当前数指针在`index[1]`时，`5`左侧比本身小的元素累加起来，故和为`3`
> - 当前数指针在`index[2]`时，`6`左侧比本身小的元素累加起来，故和为`8`
> - 当前数指针在`index[3]`时，`3`左侧没有比本身小的元素，故和为`0`
> - 当前数指针在`index[4]`时，`7`左侧比本身小的元素累加起来，故和为`17`
> - 当前数指针在`index[5]`时，`8`左侧比本身小的元素累加起来，故和为`24`
> - 当前数指针在`index[6]`时，`9`左侧比本身小的元素累加起来，故和为`32`
> - 当前数指针在`index[5]`时，`2`左侧没有比本身小的元素，故和为`0`
> - 最终所有和累加起来为`84`

```java
public class SmallSumCase {
    public static void main(String[] args) {
        int[] sumArr = new int[]{3, 5, 6, 3, 7, 8, 9, 2};
        int smallSum = calcu(sumArr);
        System.out.println("smallSum = " + smallSum);
    }

    private static int calcu(int[] sumArr) {
        // 不存在小和
        if (sumArr == null || sumArr.length < 2) {
            return 0;
        }

        // 初始化小和
        int smallSum = 0;

        // 每个元素挨个和右边元素进行对比
        for (int i = 0; i < sumArr.length; i++) {
            for (int j = 0; j < i; j++) {
                // 对小的元素进行累加和
                smallSum += sumArr[j] < sumArr[i] ? sumArr[j] : 0;
            }
        }
        return smallSum;
    }
}
```

> 执行结果

![image-20231124031303418](https://article.biliimg.com/bfs/article/edca9c3aab14157a59b9c06fd23f66e8592558693.png)

##### 归并排序实现

> 同样一个数组，例如[3,5,6,3,7,8,9,2]，实现思路如下：
>
> - 将数组拆分为左右两组，一直拆分到不可拆分为止
>
>   将`3,5,6,3,7,8,9,2`拆分为两组，左组`3,5,6,3`,右组`7,8,9,2`
>
> - 再将`3,5,6,3`拆分为两组，左组`3,5`,右组`6,3`
>
> - 再将`3,5`拆分为两组，左组`3`,右组`5`
>
> - 以此类推`7,8,9,2`同上
>
> 然后两组进行对比
>
> - 左组元素比右组元素小则将左组元素拷贝到新的数组，这时会产生小和，反之右组比左组小，固然先拷贝右组元素到新的数组中，但这种情况是不存在小和问题的，我们要求的是每一个元素左边比自身小的元素累加和。
>
> - 以`[3,5,6,3]`为例：
> - 左组`3`,右组`5`，对比得到 `3<5`，这时会将`3`拷贝到新的数组中，然后左组指针移动到下一个元素发现元素越界，再拷贝`5`,同时也产生了`小和问题`
> - 根据数组下标计算可得`右组有一个元素比3大`，固小和产生一个`1`，本轮`sum`=1 
>
> - 以`[6,3]`为例：
> - 左组6，右组3，对比得到`6>3`,这是会将右组`3`拷贝到新的数组中，然后移动右组指针到下一个元素发现元素越界，再将拷贝`6`，此时没有小和产生
> - 以`[3,5]|[3,6]`为例：
> - 左组`3`与右组`3`对比，两元素相等，先拷贝右边，右组指针指向下一个元素，再拷贝左边，不存在小和
> - 左组`3`与右组`6`对比，`3<6`,先拷贝`3`，移动左组指针到下一个元素`5`上，产生小和 一个`3`,本轮`sum=3` 
> - 左组`5`与右组`6`对比，`5<6`,先拷贝`5`，指针移动到下一个元素，发生越界，再拷贝右组`6`,这里存在小和，一个`5`,本轮`sum=5`
> - 最终得到`[3,3,5,6]`
> - `右组`[7,8,9,2]`以此类推得到`[2,7,8,9]
> - 最后再将[3,3,5,6]和`[2,7,8,9]`进行对比得到最终有序数组`[2,3,3,5,6,7,8,9]`
> - 再以上过程中也肯定出现了对应的小和，最终结果见代码实现

```java
public class SmallSumCase {
    public static void main(String[] args) {
        int[] sumArr = new int[]{3, 5, 6, 3, 7, 8, 9, 2};
        int Left = 0;
        int Right = sumArr.length - 1;

        int smallSum = process(sumArr, Left, Right);

        for (int i : sumArr) {
            System.out.print(i + "\t");
        }

        System.out.println("smallSum = " + smallSum);
    }

    private static int process(int[] sumArr, int startIndex, int endIndex) {
        // 开始到结束只存在一个数，不存在小和问题，不做累加操作
        if (startIndex == endIndex) {
            return 0;
        }

        // 取中位数
        int mid = startIndex + ((endIndex - startIndex) >> 1);

        // 左组区间划分
        int processLeftResult = process(sumArr, startIndex, mid);

        // 右组区间划分
        int processRightResult = process(sumArr, mid + 1, endIndex);

        // 归并排序并返回小和
        int mergeResult = merge(sumArr, startIndex, mid, endIndex);

        // 由于三个阶段都有可能产生小和，因此需要将三个阶段的小和进行累加
        return processLeftResult + processRightResult + mergeResult;
    }

    private static int merge(int[] sumArr, int startIndex, int mid, int endIndex) {
        // 定义缓存数组
        int[] tmpArr = new int[endIndex - startIndex + 1];
        // 定义缓存数组启始索引
        int tmpArrIdx = 0;

        // 定义左右组的指针所在位置
        int LMergeStartIdx = startIndex;
        int RMergeStartIdx = mid + 1;

        // 定义小和初始值
        int smallResult = 0;

        // 左右组都没发生越界
        while (LMergeStartIdx <= mid && RMergeStartIdx <= endIndex) {
            // 因为走到这里，无论什么样的数组 左右两边都已经经过层层排序都是是有序的了
            // 所以我们只需要考虑右组有多少个元素是比左组当前的元素大，就会产生多少个对应左组元素的小和
            // 那么我们只需要知道右组最后一个元素到当前右组指针位置这中间存在多少个元素即可
            // 产生小和就累加小和，没有小和产生则累加0即可
            smallResult += sumArr[LMergeStartIdx] < sumArr[RMergeStartIdx] ? (endIndex - RMergeStartIdx + 1) * sumArr[LMergeStartIdx] : 0;

            // 拷贝数组并移动指针
            tmpArr[tmpArrIdx++] = sumArr[LMergeStartIdx] < sumArr[RMergeStartIdx] ? sumArr[LMergeStartIdx++] : sumArr[RMergeStartIdx++];
        }

        // 右组越界，拷贝左组
        while (LMergeStartIdx <= mid) {
            tmpArr[tmpArrIdx++] = sumArr[LMergeStartIdx++];
        }

        // 左组越界，拷贝右组
        while (RMergeStartIdx <= endIndex) {
            tmpArr[tmpArrIdx++] = sumArr[RMergeStartIdx++];
        }

        // 将有序元素替换到原 sumArr 数组中对应位置上
        for (int i = 0; i < tmpArr.length; i++) {
            sumArr[startIndex + i] = tmpArr[i];
        }

        return smallResult;
    }
}
```

> 执行结果

![image-20231124024024070](https://article.biliimg.com/bfs/article/5f5aaf2d15b409031f4db169e6374090592558693.png)

##### 对数器验证

```java
public static void main(String[] args) {
  int testTime = 500_000;
  int maxSize = 100;
  int maxValue = 100;

  System.out.println("--- SmallSumCase test start ---");


  for (int i = 0; i < testTime; i++) {
    int[] arr1 = CommonUtils.buildRandomArray(maxSize, maxValue);
    int[] arr2 = CommonUtils.copyArray(arr1);

    if (calcu(arr1) != calcuByMergeSort(arr2)) {
      System.out.println("SmallSumCase test error");
      printArray(arr1);
      printArray(arr2);
    }
  }
  System.out.println("--- SmallSumCase test success ---");
}


// 新增方法：包装递归调用
private static int calcuByMergeSort(int[] arr2) {
  int Left = 0;
  int Right = arr2.length - 1;

  return process(arr2, Left, Right);
}
```

> 验证结果

![image-20231124032035856](https://article.biliimg.com/bfs/article/e5ee26d3d61fb8d0929421b0ccdd4d47592558693.png)

#### 逆序对问题

> 在一数组中，若将两元素看为一组，且这组数据左边元素比右边元素大，称作逆序对，如有数组`[5，8，3，7，2，4]`：
>
> - 以元素`[5]`为视角，则`5,3`、`[5,2]`、`[5,4]`构成逆序对
> - 以元素`[8]`为视角，则`8,3`、`[8,7]`、`[8,2]`、`[8,4]`构成逆序对
> - 以元素`[3]`为视角，则`3,2`构成逆序对
> - 以元素`[7]`为视角，则`7,2`、`[7,4]`构成逆序对
>
> 综上所述：我们只需要关注每个元素右边有多少元素比当前元素小即可，只需要注意排序的规则
>
> - 如果是降序排，则从左往右拷贝
>
> - 如果是升序排，则从右往左拷贝

##### 非归并实现

```java
private static int calcu(int[] arr) {
    if (arr == null || arr.length < 2) {
        return 0;
    }

    int count = 0;

    for (int i = 0; i < arr.length; i++) {
        for (int j = i+1; j < arr.length ; j++) {
            // 对小的元素进行累加和
            count += arr[j] < arr[i] ? 1 : 0;
        }
    }
    return count;
}
```

##### 归并排序实现

```java
public class ReverseOrderCase {
   
    private static int calcuByMergeSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }

        int Left = 0;
        int Right = arr.length - 1;
        return process(arr, Left, Right);
    }

    private static int process(int[] arr, int startIndex, int endIndex) {
        // 开始到结束只存在一个数，不存在小和问题，不做累加操作
        if (startIndex == endIndex) {
            return 0;
        }

        // 取中位数
        int mid = startIndex + ((endIndex - startIndex) >> 1);

        // 由于三个阶段都有可能产生逆序对，因此需要将三个阶段的小和进行累加
        return process(arr, startIndex, mid) + process(arr, mid + 1, endIndex) + merge(arr, startIndex, mid, endIndex);
    }

    private static int merge(int[] arr, int startIndex, int mid, int endIndex) {

        // 定义缓存数组
        int[] tmpArr = new int[endIndex - startIndex + 1];
        // 定义缓存数组启始索引 从右往左存
        int tmpArrIdx = tmpArr.length - 1;

        // 定义左右组的指针所在位置，左组从中位往左移，右组从最大长度往中位移
        int LMergeStartIdx = mid;
        int RMergeStartIdx = endIndex;

        // 定义逆序对总数初始值
        int reverseOrderCount = 0;

        // 左右组都没发生越界
        while (LMergeStartIdx >= startIndex && RMergeStartIdx > mid) {
            // 计算从右组当前指针位置到右组起始索引有多少个元素即为存在多少组逆序对
            reverseOrderCount += arr[LMergeStartIdx] > arr[RMergeStartIdx] ? (RMergeStartIdx - mid) : 0;
            // 拷贝数组并移动指针，我们这里是升序排，所以从右往左拷贝
            tmpArr[tmpArrIdx--] = arr[LMergeStartIdx] > arr[RMergeStartIdx] ? arr[LMergeStartIdx--] : arr[RMergeStartIdx--];
        }

        // 右组越界，拷贝左组
        while (LMergeStartIdx >= startIndex) {
            tmpArr[tmpArrIdx--] = arr[LMergeStartIdx--];
        }

        // 左组越界，拷贝右组
        while (RMergeStartIdx > mid) {
            tmpArr[tmpArrIdx--] = arr[RMergeStartIdx--];
        }

        // 将有序元素替换到原 arr 数组中对应位置上
        for (int i = 0; i < tmpArr.length; i++) {
            arr[startIndex + i] = tmpArr[i];
        }

        return reverseOrderCount;
    }
}
```

##### 对数器验证

```java
public static void main(String[] args) {
    int testTime = 500_000;
    int maxSize = 100;
    int maxValue = 100;

    System.out.println("--- ReverseOrderCase test start ---");


    for (int i = 0; i < testTime; i++) {
        //            int[] arr1 = new int[]{8, 7, 3, 4, 3, 7, 2};

        int[] arr1 = CommonUtils.buildRandomArray(maxSize, maxValue);
        int[] arr2 = CommonUtils.copyArray(arr1);

        int calcu = calcu(arr1);

        int calcuByMergeSort = calcuByMergeSort(arr2);

        if (calcu != calcuByMergeSort) {
            System.out.println("ReverseOrderCase test error");
            printArray(arr1);
            printArray(arr2);
            return;
        }
    }
    System.out.println("--- ReverseOrderCase test success ---");
}
```

####  两倍小值问题

> 有一任意数组`[5，8，3，7，2，4]`,求每个元素右边范围有多少个元素 `本身 * 2 < 当前元素`，要求返回总计数值
>
> - 以元素`[5]`为视角，故有`1`个元素满足条件：`[2]`，`count = 1`
> - 以元素`[8]`为视角，故有`3`个元素满足条件：`[3，2]`，`count = 2`
> - 以元素`[3]`为视角，故有`0`个元素满足条件，`count = 0`
> - 以元素`[7]`为视角，故有`1`个元素满足条件：`[2]`，`count = 1`
> - 以元素`[2]`为视角，故有`0`个元素满足条件，`count = 0`
> - 以元素`[4]`为视角，故有`0`个元素满足条件，`count = 0`
> - 最终总计数值为`4`

##### 非递归实现

```java
private static int calcu(int[] arr) {
    if (arr == null || arr.length < 2) {
        return 0;
    }

    int result = 0;
    for (int i = 0; i < arr.length; i++) {
        for (int j = i + 1; j < arr.length; j++) {
            result += (arr[j] * 2) < arr[i] ? 1 : 0;
        }
    }
    return result;
}
```

##### 归并排序实现

> 指针不回退实现思路：
>
> - 将一个数组拆分为左右组，分别使其组内有序，定义两个指针分别卡住左右组起始元素。
> - 当右组元素 * 2 < 左组当前元素时，指针向右移动
> - 当右组元素 * 2 >= 左组当前元素时, 左组指针向右移动
> - 因为两组数组都已是组内有序（假设升序），故右组元素 < 左组前一个元素的也必然小于左组当前的元素
> - 因此我们只需要关注右组指针最终所在位置的前面有多少个元素即可

```java
private static int calcuByMergeSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return 0;
    }
    return process(arr, 0, arr.length - 1);
}

private static int process(int[] arr, int L, int R) {
    if (L == R) {
        return 0;
    }

    // 取中位数
    int M = L + ((R - L) >> 1);

    // 三阶段总数和
    return process(arr, L, M) + process(arr, M + 1, R) + merge(arr, L, M, R);
}

private static int merge(int[] arr, int L, int M, int R) {
    int result = 0;

    // 定义一个指针卡住右组最大的元素
    int IDX = M + 1;

    // 统计每个元素右边值乘以2仍小于当前元素值的总个数
    for (int i = L; i <= M; i++) {
        // 控制IDX指针的滑动 && 左组当前元素要比IDX所在位置前一个元素大  arr[IDX] << 1 == arr[IDX]*2
        while (IDX <= R && arr[i] > arr[IDX] << 1) {
            IDX++;
        }
        // 统计 [M,IDX-1)区间上的元素个数
        // 例如 [1,2,3,4,1,2,3,5] 拆分为两组 [1,2,3,4] [1,2,3,5]
        // 当arr[0]指向[1]得时候，IDX指向 M+1 =[1],1 > 1*2 ? 不满左组比右组大
        // IDX指针不能滑动到下一个元素，还在M+1位置上，因为最少为0 ，所以由IDX = M+1得到 0 = M+1-M-1
        result += IDX - M - 1;
    }

    // 定义左右组的指针所在位置
    int LMergeStartIdx = L;
    int RMergeStartIdx = M + 1;

    // 定义临时空间排序数组元素
    int[] tmpArr = new int[R - L + 1];
    // 定义临时数组起始索引
    int tmpArrIdx = 0;

    // 左右组都没发生越界
    while (LMergeStartIdx <= M && RMergeStartIdx <= R) {
        // 拷贝数组并移动指针
        tmpArr[tmpArrIdx++] = arr[LMergeStartIdx] < arr[RMergeStartIdx] ? arr[LMergeStartIdx++] : arr[RMergeStartIdx++];
    }

    // 右组越界，拷贝左组
    while (LMergeStartIdx <= M) {
        tmpArr[tmpArrIdx++] = arr[LMergeStartIdx++];
    }

    // 左组越界，拷贝右组
    while (RMergeStartIdx <= R) {
        tmpArr[tmpArrIdx++] = arr[RMergeStartIdx++];
    }

    // 将有序元素替换到原 arr 数组中对应位置上
    for (int i = 0; i < tmpArr.length; i++) {
        arr[L + i] = tmpArr[i];
    }

    return result;
}
```

##### 对数器验证

```java
public static void main(String[] args) {
    int testTime = 500_000;
    int maxSize = 100;
    int maxValue = 100;

    System.out.println("--- DoubleSumCase test start ---");


    for (int i = 0; i < testTime; i++) {
        // int[] arr1 = new int[]{5, 8, 3, 7, 2, 4};

        int[] arr1 = CommonUtils.buildRandomArray(maxSize, maxValue);
        int[] arr2 = CommonUtils.copyArray(arr1);

        int calcu = calcu(arr1);

        int calcuByMergeSort = calcuByMergeSort(arr2);

        if (calcu != calcuByMergeSort) {
            System.out.println("DoubleSumCase test error");
            printArray(arr1);
            printArray(arr2);
            return;
        }
    }
    System.out.println("--- DoubleSumCase test success ---");
}
```

#### 区间和的个数🔥

> [给你一个整数数组 `nums` 以及两个整数 `lower` 和 `upper` 。求数组中，值位于范围 `[lower, upper]` 之内的 **区间和的个数** 。**区间和** `S(i, j)` 表示在 `nums` 中，位置从 `i` 到 `j` 的元素之和，包含 `i` 和 `j` (`i` ≤ `j`)](https://leetcode.cn/problems/count-of-range-sum/description/)

##### 非递归实现

> **子数组枚举法**
>
> - (0,0) 范围上子数组: [-1]
> - (0,1) 范围上子数组: [-1，5]
> - (0,2) 范围上子数组: [-1，5，7]
> - ... 以此类推 ...
>
> **复杂度推算**
>
> - 子数组的数量是平方级，(0,0) ... (0,N-1) 、(1,1) .. (1,N-1)、(2,2) .. (2,N-1)
> - 如果遍历获取这些子数组一般是双层嵌套循环，因此复杂度为`O(N^2)`
> - 又因为我们每次都要再遍历验证输入条件范围内的值，因此复杂度升阶为`O(N^3)`
>
> **复杂度优化一阶段**
>
> - 为了避免每次都遍历验证导致复杂度加深，我们可以提前对原数组遍历一遍，得到一个前缀和数组并保存到额外的数组空间内。
>
> - 例如数组`[-1,5,7,-3,7,-2,6]`
>
> - 遍历`nums`得到一个`前缀和数组 preSumArr -> [-1,4,11,8,15,13,19]`
> - 如要求`Sum(3,6)`范围上的元素累加和
> - 根据 `Sum(i,j) = preSum(0,j) - preSum(0,i-1)`则可用 `preSum(0,6) - preSum(0,2) = 19 - 11 = Sum(3,6) = (-3+7-2+6) =  8`   
> - 如此我们每次直接在前缀和数组中取对应位置的前缀和来直接进行计算，则可将原`O(N^3)`降阶为`O(N^2)`
>
> **复杂度优化二阶段**
>
> **假设`(0,i)`位置整体累加和为 X，`[lower, upper]=[-2,5]`，求必须以`i`位置结尾子数组有多少组在`[-2,5]`范围上，例如数组`[-1,5,7,-3,7,-2,6]`**
>
> - **`i=3`；以`[3]`结尾的子数组如下：**
>
> - `(3,3)范围：[-3]`累加和为：`-3`，不在`【-2, 5】`值范围上
>
> - `(2,3)范围：[7，-3]`累加和为：`4`，在`【-2, 5】`值范围上
>
> - `(1,3)范围：[5,7,-3]`累加和为：`9`，不在`【-2, 5】`值范围上
>
> - `(0,3)范围：[-1，5，7，-3]`累加和为：`8`，不在`【-2, 5】`值范围上
>
>   **有`1`个子数组的累加和在`【-2, 5】`值范围上区间**
>
> - **`i=2`；以`[2]`结尾的子数组如下：**
>
> - `(2,2)范围：[7]`累加和为：`7`，不在`【-2, 5】`值范围上
>
> - `(1,2)范围：[5，7]`累加和为：`12`，不在`【-2, 5】`值范围上
>
> - `(0,2)范围：[-1，5，7]`累加和为：`11`，不在`【-2, 5】`值范围上
>
>   **有`0`个子数组的累加和在`【-2, 5】`值范围上区间**
>
> - **`i=1`；以`[1]`结尾的子数组如下：**
>
> - `(1,1)范围：[5]`累加和为：`5`，在`【-2, 5】`值范围上
>
> - `(0,1)范围：[-1，5]`累加和为：`4`，在`【-2, 5】`值范围上  
>
>   **有`2`个子数组的累加和在`【-2, 5】`值范围上区间**
>
> - **`i=0`；以`[0]`结尾的子数组如下：**
>
> - `(0,0)范围：[-1]`累加和为：`-1`，在`【-2, 5】`值范围上
>
>   **有`1`个子数组的累加和在`【-2, 5】`值范围上区间**
>
> 最终得总数：`1+0+2+1=4` 
>
> **概念转换**：**求`i`位置之前的所有前缀和中有多少个前缀和在`[X-upper,X-lower]`范围上** `等同于` **以上方式**
>
> - 例如数组`[-1,5,7,-3,7,-2,6]`，提前得到`前缀和数组 preSumArr -> [-1,4,11,8,15,13,19]`
>
>   **令`(0,3)`范围整体累加和为 `8` ，故`X=8 `**
>
> - 根据`[X-upper,X-lower]`得：`[8-5,8-(-2)] =[3,10]`
>
> - 因此我们只需要在`(0,3)`位置上，前缀和在【3，10】区间内的有多少个即可
>
> - 那么在`[-1,4,11,8]`中满足条件的为`2`个
>
>   ... 以此类推 ...

##### 归并排序实现

```java
public class CountRangeSumCase {

    public int countRangeSum(int[] nums, int lower, int upper) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        // 定义前缀和数组
        long[] preSumArr = new long[nums.length];

        // 第一个元素没有累加元素，即为本身
        preSumArr[0] = nums[0];
        // 计算第二个元素开始的前缀和
        for (int i = 1; i < nums.length; i++) {
            preSumArr[i] = nums[i] + preSumArr[i - 1];
        }

        return process(preSumArr, 0, preSumArr.length - 1, lower, upper);
    }

    private static int process(long[] preSumArr, int L, int R, int lower, int upper) {
        // 求在原始arr[L...R]中，有多少个子数组累加和在【lower,upper】上
        if (L == R) {
            // 代表从0 ... L找到一个原始子数组
            return preSumArr[L] >= lower && preSumArr[L] <= upper ? 1 : 0;
        }
        int M = L + ((R - L) >> 1);
        return process(preSumArr, L, M, lower, upper) + process(preSumArr, M + 1, R, lower, upper) + merge(preSumArr, L, M, R, lower, upper);
    }

    private static int merge(long[] preSumArr, int L, int M, int R, int lower, int upper) {
        int result = 0;
        // 滑动窗口，winL不能小于 X-upper ,winR 不能大于 X-lower
        int winL = L;
        int winR = L;

        // 计算达标元素个数
        for (int i = M + 1; i <= R; i++) {
            // X-upper
            long min = preSumArr[i] - upper;
            // X-lower
            long max = preSumArr[i] - lower;
            // preSumArr[winR]如果比max值小窗口右边界就往右滑动，但是最多滑到中点位置
            while (winR <= M && preSumArr[winR] <= max) {
                winR++;
            }
            // preSumArr[winL]如果比min值小窗口左边界就往右滑动，但是最多滑到中点位置
            while (winL <= M && preSumArr[winL] < min) {
                winL++;
            }
            // 比如 winL = 0, winR = 3 , 3-0就能得到中间包含几个数，随着指针移动，就能得到整个长度总共有多少元素符合条件
            result += winR - winL;
        }

        // 合并
        // 定义临时空间排序数组元素
        long[] tmpArr = new long[R - L + 1];
        // 定义临时数组起始索引
        int idx = 0;
        // 定义左右组的指针所在位置
        int partLStartIdx = L;
        int partRStartIdx = M + 1;

        // 左右组都没发生越界
        while (partLStartIdx <= M && partRStartIdx <= R) {
            // 拷贝数组并移动指针
            tmpArr[idx++] = preSumArr[partLStartIdx] <= preSumArr[partRStartIdx] ? preSumArr[partLStartIdx++] : preSumArr[partRStartIdx++];
        }

        //右组越界，拷贝左组
        while (partLStartIdx <= M) {
            tmpArr[idx++] = preSumArr[partLStartIdx++];
        }

        // 左组越界，拷贝右组
        while (partRStartIdx <= R) {
            tmpArr[idx++] = preSumArr[partRStartIdx++];
        }

        // 将有序元素替换到原 nums 数组中对应位置上
        for (int i = 0; i < tmpArr.length; i++) {
            preSumArr[L + i] = tmpArr[i];
        }

        return result;
    }
}
```

## 快速排序

### 前置知识引入案例一

> 有一数组`[2,5,7,9,3,5,8,1,3]`，取数组最后一位元素作为`区分值`
>
> - 需使`<=3`的数放`区分值`的左边,`>3`的放 `区分值`的右边，并且左边区域最右边的值为`区分值对应的元素`左右两边区域元素无需有序

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2023/9/19 9:59 PM
 */
public class QuickSortBasicKnowledge {
    public static void main(String[] args) {
        int[] arr = {2, 5, 7, 9, 3, 5, 8, 1, 3};
        partitionNum(arr);
        CommonUtils.printArray(arr);
    }

    public static void partitionNum(int[] arr) {
        // 记录小于右边元素的指针位置
        int lessRightIndex = -1;

        // 当前数所在的指针位置
        int currIndex = 0;

        // 数组最右侧元素位置(区分值)
        int mostRightIndex = arr.length - 1;

        while (currIndex < arr.length) {
            // 从数组第一个元素开始挨个和后面元素进行对比，只要出现`<=区分值`的元素，
            // 即将当前指定所在位置的元素和`上一次小于区分值元素所在位置的下一个元素`进行元素交换
            if (arr[currIndex] <= arr[mostRightIndex]) {
                CommonUtils.swap(arr, ++lessRightIndex, currIndex++);
            } else {
                // 当前指针所在位置的元素比区分值大，直接将当前指针移动到下一个元素上进行下一次对比
                currIndex++;
            }
        }

    }
}
```

> 执行结果

![image-20230920003905766](https://article.biliimg.com/bfs/article/a37eae8186630998b2b92f9f619e6470592558693.png)

### 前置知识引入案例二

> 有一数组`[2,5,7,9,3,5,8,1,3]`，取数组最后一位元素作为`区分值`
>
> - 需将最终数组分为以下三部分，使`<3`的在数组左边区域（可无序）、`=3`的在数组中间部分（有序）、`>3`的在数组右边区域（可无序）

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2023/9/19 9:59 PM
 */
public class QuickSortBasicKnowledge {
  public static void main(String[] args) {
    int[] arrAdvanced = {2, 5, 7, 9, 3, 5, 8, 1, 3};
    partitionNumAdvanced(arrAdvanced);
    CommonUtils.printArray(arrAdvanced);
  }

  public static void partitionNumAdvanced(int[] arr) {

    // 当前数所在的指针位置
    int currIndex = 0;

    // 数组最右侧元素位置(区分值)
    int mostRightIndex = arr.length - 1;

    // 记录小于于区分值区域元素的指针位置
    int lessIndex = -1;

    // 记录大于区分值区域元素的指针位置
    int greaterIndex = mostRightIndex;

    // 当两边区域的交换指针没有相遇代表还没结束对比
    while (currIndex < greaterIndex) {
      // 当前位置元素小于区分值
      if (arr[currIndex] < arr[mostRightIndex]) {
        // 小于区域的直接交换位置即可
        CommonUtils.swap(arr, ++lessIndex, currIndex++);
      } else if (arr[currIndex] > arr[mostRightIndex]) {
        // 大于区域的指针从右往左移动，记录交换元素的指针位置，当前指针不动，任然指向原来位置
        // 因为交换过来的元素不知道是大是小，还需要进一步对比
        CommonUtils.swap(arr, --greaterIndex, currIndex);
      } else {
        // 因为我们要保证中间区域是等于分区值的区域元素有序，因此不用交换数据，需要交换元素的是大于和小于区分值的区域
        currIndex++;
      }
    }
    // 由于最后一个分区值一直没有动，因此还需要将这个值与`大于分区值区域的第一个元素（就是greaterIndex最后记录的位置）`做元素交换才能保证中间区域有序
    CommonUtils.swap(arr, greaterIndex, mostRightIndex);
  }
}
```

> 运行结果

![image-20230920014837190](https://article.biliimg.com/bfs/article/7d1bb985f44f523e475d7001685ce1ca592558693.png)

> 那么以上两种案例跟快排到底有什么区别呢
>
> - 上面两种案例我们只做了第一层排序，其实第二种案例才真正意义上排好了中间区域，但是左右区域的元素仍然是乱序的，而快排真正干的事情就是排好中间的然后一直不停的去拍左右两个区域的元素，直到全部有序为止
>
> 那么来看看快排的写法，大致思想与案例二中相似，多的操作就是对左右区间的元素进行排序操作

### 公共代码提取

```java
public class QuickSortByPartition {
  public static int[] partition(int[] arr, int leftIndex, int rightIndex) {
    // 由于递归调用，因此参数列表中的leftIndex和rightIndex可能每次都是不一样的
    // 当前数所在的指针位置,从分区数组的最左侧开始
    int currIndex = leftIndex;

    // 数组最右侧元素位置(区分值)，不管是对哪个分区进行排序，始终认定有效区间内的最右边元素为区分值
    int mostRightIndex = rightIndex;

    // 记录小于于区分值区域元素的指针位置
    int lessIndex = leftIndex - 1;

    // 记录大于区分值区域元素的指针位置
    int greaterIndex = mostRightIndex;

    // 当两边区域的交换指针没有相遇代表还没结束对比
    while (currIndex < greaterIndex) {
      // 当前位置元素小于区分值
      if (arr[currIndex] < arr[mostRightIndex]) {
        // 小于区域的直接交换位置即可
        CommonUtils.swap(arr, ++lessIndex, currIndex++);
      } else if (arr[currIndex] > arr[mostRightIndex]) {
        // 大于区域的指针从右往左移动，记录交换元素的指针位置，当前指针不动，任然指向原来位置
        // 因为交换过来的元素不知道是大是小，还需要进一步对比
        CommonUtils.swap(arr, --greaterIndex, currIndex);
      } else {
        // 因为我们要保证中间区域是等于分区值的区域元素有序，因此不用交换数据，需要交换元素的是大于和小于区分值的区域
        currIndex++;
      }
    }
    // 由于最后一个分区值一直没有动，因此还需要将这个值与`大于分区值区域的第一个元素（就是greaterIndex最后记录的位置）`做元素交换才能保证中间区域有序
    CommonUtils.swap(arr, greaterIndex, mostRightIndex);
    return new int[]{++lessIndex, greaterIndex};
  }
}
```

### 栈实现

> 我们需要新建一个实体用来接收每次分区返回的边界索引

```java
public class Job {
  private int leftIndex;
  private int rightIndex;

  public Job(int leftIndex, int rightIndex) {
    this.leftIndex = leftIndex;
    this.rightIndex = rightIndex;
  }

  public int getLeftIndex() {
    return leftIndex;
  }


  public int getRightIndex() {
    return rightIndex;
  }
}
```

> 具体实现

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2023/9/19 9:59 PM
 */
public class QuickSortByPartition {
  public static void quickSortNonRecursion(int[] arr) {
    if (arr != null && arr.length >= 2) {
      // 使用栈结构保存任务
      Stack<Job> jobs = new Stack<>();

      // 往栈里压任务
      jobs.push(Job.builder()
                .leftIndex(0)
                .rightIndex(arr.length - 1)
                .build());

      while (!jobs.isEmpty()) {
        // 只要栈中存在任务，则进行分区然后对左右区间进行判断，符合条件则将对应的区间任务压入栈中
        Job job = jobs.pop();
        int[] partition = partition(arr, job.getLeftIndex(), job.getRightIndex());

        // 返回的左边界索引其实就是中间相等元素的左边界，右边界索引则是中间相等元素的右边界
        // 左边界索引 > 当前任务的最左边界索引代表存在`小于分区值`的左区域
        if (partition[0] > job.getLeftIndex()) {
          jobs.push(Job.builder()
                    .leftIndex(job.getLeftIndex())
                    .rightIndex(partition[0] - 1)
                    .build());
        }
        // 右边界索引 < 当前任务的最右边界索引代表存在`大于分区值`的右区域
        if (partition[1] < job.getRightIndex()) {
          jobs.push(Job.builder()
                    .leftIndex(partition[1] + 1)
                    .rightIndex(job.getRightIndex())
                    .build());
        }
      }
    }
  }
}
```

### 递归实现

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2023/9/19 9:59 PM
 */
public class QuickSortByPartition {
  public static void quickSort(int[] arr) {
    if (arr != null && arr.length >= 2) {
      // 递归调用分区交换元素
      process(arr, 0, arr.length - 1);
    }
  }

  private static void process(int[] arr, int leftIndex, int rightIndex) {
    if (leftIndex < rightIndex) {
      // 获取每个阶段数组的分区范围
      int[] ints = partition(arr, leftIndex, rightIndex);
      // 递归对左边区间内数组元素进行排序
      process(arr, leftIndex, ints[0] - 1);
      // 递归对右边边区间内数组元素进行排序
      process(arr, ints[1] + 1, rightIndex);
    }
  }
}
```

### 对数器验证

> 将栈实现和递归实现的结果使用对数器随机造数进行对比最终结果

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2023/9/19 9:59 PM
 */
public class QuickSortByPartition {
  public static void main(String[] args) {

    int testTime = 500_000;
    int maxSize = 100;
    int maxValue = 100;

    System.out.println("--- QuickSort test start ---");
    for (int i = 0; i < testTime; i++) {
      int[] arr1 = CommonUtils.buildRandomArray(maxSize, maxValue);
      int[] arr2 = CommonUtils.copyArray(arr1);

      // 递归法
      quickSort(arr1);
      // 栈操作
      quickSortNonRecursion(arr2);

      if (!CommonUtils.isEqual(arr1, arr2)) {
        System.out.println("QuickSort test error");
        printArray(arr1);
        printArray(arr2);
      }
    }
    System.out.println("--- QuickSort test success ---");

  }
}
```

> 验证通过，说明最终两个实现方法得到的结果都是一致的，综上所述，这就是快排

![image-20230920033332178](https://article.biliimg.com/bfs/article/7b98fe48f764057404670a83edd3dcf6592558693.png)

### 随机快排

#### 荷兰国旗问题

> 一个数组中，给定一个数X，不使用辅助数组实现以下两种情况
>
> **<=X放数组左边，>=X的放数组右边**（不要求左右都有序，时间复杂度O(N)）
>
> - 划分一个小于当前数的区域，从-1位置开始卡住边界
> - 当前数<=目标数，当前数和【小于区域】的下一个数交换，【小于区域】向右覆盖一个位置，当前数指针跳下一个位置
> - 当前数>目标数，当前数的指针跳到下一个数上
>
> **<X放左边，=X放中间，>X放右边**（不要求左右都有序，时间复杂度O(1)/O(N)）
>
> - 划分一个小于当前数的区域从-1位置开始卡住边界，再分一个大于当前数的区域，从数组length位置卡住边界
> - 当前数<目标数，当前数和【小于区域】的下一个数交换，【小于区域】向右覆盖一个位置，当前数指针跳下一个位置
> - 当前数=目标数，当前数的指针跳到下一个数上
> - 当前数>目标数，当前数和【大于区域】指针的前一个数交换，【大于区域】向左覆盖一个位置，当前数指针停在原地

```java
public class DutchFlagIssue {

    public void quicksort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        process(arr, 0, arr.length - 1);
    }

    private void process(int[] arr, int L, int R) {
        if (L < R) {
            //通过随机数将一个随机位置的元素和R位置的划分值交换，防止分区数据严重倾斜导致复杂度偏高
            swap(arr, (int) (L + Math.random() * (R - L + 1)), R);
            int[] dutchFlagArea = dutchFlag(arr, L, R);
            //左区处理,L...【等于区域左边界】
            process(arr, L, dutchFlagArea[0]);
            //右区处理，【等于区域右边界】...最后一位元素
            process(arr, dutchFlagArea[1] + 1, R);
        }
    }


    public static int[] dutchFlag(int[] arr, int L, int R) {
        if (L > R) {
            return new int[]{-1, -1};
        }

        if (L == R) {
            return new int[]{L, R};
        }
        //定义【小于区域】右边界
        int less = L - 1;
        //定于【大于区域】左边界，因为要把数组最后一个数摘出来做划分值，所以直接以最后一个元素位置作为边界
        int more = R;
        // 定义当前指针位置
        int currIdx = L;
        // 当前指针位置不能撞上【大于区域】左边界
        while (currIdx < more) {
            if (arr[currIdx] == arr[R]) {
                // 当前数=目标数，当前数的指针跳到下一个数上
                currIdx++;
            } else if (arr[currIdx] < arr[R]) {
                //当前数<目标数，当前数和【小于区域】的下一个数交换，【小于区域】向右覆盖一个位置，当前数指针跳下一个位置
                swap(arr, currIdx++, ++less);
            } else {
                //当前数>目标数，当前数和【大于区域】指针的前一个数交换，【大于区域】向左覆盖一个位置，当前数指针停在原地
                swap(arr, currIdx, --more);
            }
        }
        // 将最后一个元素和【大于区域】第一个元素交换位置
        // 此时 <R =R >R 就已经完成了
        swap(arr, more, R);

        // 返回=R的起始位置和结束位置
        return new int[]{less + 1, more};
    }
}
```

## 堆

> - 随意添加值
> - 支持pop最大值并且维持住堆的结构

### 手写堆

> 父节点比子节点大

```java
public class Heap {
    /*
     * 大根堆
     */
    static class MaxHeap {
        private int[] heap;
        private int limit;
        private int heapSize;

        public MaxHeap(int limit) {
            this.limit = limit;
            this.heap = new int[limit];
            this.heapSize = 0;
        }

        public boolean isEmpty() {
            return this.heapSize == 0;
        }

        public boolean isFull() {
            return this.heapSize == this.limit;
        }

        public void push(int val) {
            if (this.heapSize == this.limit) {
                throw new RuntimeException("heap is full!");
            }
            // val放到heap对应位置
            this.heap[this.heapSize] = val;
            // 向上升级
            upGrades(this.heap, this.heapSize++);
        }

        // 返回最大值，并且删除大根堆中的最大值
        public int pop() {
            int result = this.heap[0];
            // 将最大的数和最后一个位置的数交换，将最大数扔到最后，等待下一次插入就会被覆盖了
            swap(this.heap, 0, --heapSize);
            // 由于最后一个位置的数被换到了根节点，破坏了堆结构，要将这个数和各级分支进行对比下沉到合适的位置
            heapIfy(this.heap, 0, heapSize);
            return result;
        }

        private void upGrades(int[] heap, int idx) {
            // 拿idx节点的值与它的父根进行比较，比父节点大则与父节点交换，依次向上对比，直到不大于父节点的值停止，或者移动到了整个堆的根节点停止
            while (heap[idx] > heap[(idx - 1) / 2]) {
                swap(heap, heap[idx], heap[(idx - 1) / 2]);
                // idx跟随移动到对应节点位置
                idx = (idx - 1) / 2;
            }
        }

        private void heapIfy(int[] heap, int idx, int heapSize) {
            // 左分支位置
            // idx为0，左分支 0*2+1 = 1;
            // idx为1，左分支 1*2+1 = 3;
            // idx为2，左分支 1*2+1 = 5;
            int left = idx * 2 + 1;
            // 从idx位置不断下沉，当较大的分支没有idx位置的数大的时候，代表已经没有分支了，停止下沉
            while (left < heapSize) {
                // 确保右分支不越界 并且 将左右分支中稍大的一个数拿出来和目标值对比
                int largest = left + 1 < heapSize && heap[left + 1] > heap[left] ? left + 1 : left;
                // 用这个较大节点值去对比父节点值，谁大把谁的下标给到largest
                largest = heap[largest] > heap[idx] ? largest : idx;
                // 代表已经是三个节点中最大的值了，不需要下沉了
                if (largest == idx) {
                    break;
                }
                // idx和较大分支的下标互换，将父节点数下沉
                swap(heap, largest, idx);
                idx = largest;
                left = idx * 2 + 1;
            }
        }
    }
}

```

### PriorityQueue

>PriorityQueue（优先级队列）
>
>不加比较器默认小顶堆

#### 小顶堆

```java
static class MinHeap {
  public static void main(String[] args) {
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    heap.add(3);
    heap.add(9);
    heap.add(6);
    System.out.println(heap.peek());

    heap.add(8);
    heap.add(5);
    System.out.println(heap.peek());

    while (!heap.isEmpty()) {
      System.out.println(heap.poll());
    }
  }
}
```

#### 大顶堆

```java
static class MaxHeapByPriorityQueue {
  public static void main(String[] args) {
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(new MaxHeapComparator());
    maxHeap.add(3);
    maxHeap.add(9);
    maxHeap.add(6);
    System.out.println(maxHeap.peek());

    maxHeap.add(8);
    maxHeap.add(5);
    System.out.println(maxHeap.peek());

    while (!maxHeap.isEmpty()) {
      System.out.println(maxHeap.poll());
    }
  }

  private static class MaxHeapComparator implements Comparator<Integer> {
    @Override
    public int compare(Integer o1, Integer o2) {
      return o2 - o1;
    }
  }
}
```

### 堆排序

> 核心思想：
>
> - 先将整个数组变成大根堆结构
>
>   - 从下往上建堆的时间复杂度为O(N)
>
>   - 从上往下建堆的间复杂度为O(N*logN)
>
> - 把堆的最大值和堆末尾的值交换，然后减少堆大小后开始调整堆，一直将堆的大小减到0后排序完成，时间复杂度为O(N*logN)

```java
public class HeapSort {
    public static void main(String[] args) {
        int[] ints = CommonUtils.buildRandomArray(10, 30);
        heapSort(ints);
        for (int i : ints) {
            System.out.print(i + "\t");
        }
    }

    public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }

        // O(N*logN):从上往下建堆是基于节点层数的
        //    for (int i = 0; i < arr.length; i++) {
        //        MaxHeap.upGrades(arr, i);
        //    }

        // O(N)
        for (int i = arr.length - 1; i >= 0; i--) {
            heapIfy(arr, i, arr.length);
        }

        int heapSize = arr.length;
        swap(arr, 0, --heapSize);

        // O(N*logN)
        while (heapSize > 0) { // O(N)
            heapIfy(arr, 0, heapSize); // O(logN)
            swap(arr, 0, --heapSize); // O(1)
        }
    }
}
```

### 练习题

> 一直一个几乎有序地数组（意思是如果把数组排好顺序的话，每个元素移动的距离一定不超过K，并且K相对于数组长度来说是比较小的）
>
> - 请选择一个合适的排序策略，对这个数组进行排序

```java
public class SortArrayDistanceLessK {
    public static void main(String[] args) {
        int[] ints = Arrays.stream(CommonUtils.buildRandomArray(10, 30)).distinct().toArray();
        ints = randomArrayNoMoveMoreK(ints, 5);

        sortArrayDistanceLessK(ints, 5);
        for (int anInt : ints) {
            System.out.print(anInt + "\t");
        }

    }

    public static void sortArrayDistanceLessK(int[] arr, int k) {
        if (k == 0) {
            return;
        }

        // 小根堆
        PriorityQueue<Integer> heap = new PriorityQueue<>();

        int index = 0;
        // 只有0 ... k-1位置的数才可能移动到0位置
        for (; index <= Math.min(arr.length - 1, k - 1); index++) {
            // 把0...k-1所有元素放到小根堆
            heap.add(arr[index]);
        }

        int i = 0;
        // 把K-1以后得数挨个从0位置开始往后放，放一个弹一个最小值出去
        for (; index < arr.length; i++, index++) {
            heap.add(arr[index]);
            arr[i] = heap.poll();
        }

        while (!heap.isEmpty()) {
            arr[i++] = heap.poll();
        }
    }

    public static int[] randomArrayNoMoveMoreK(int[] arr, int K) {
        // 先排个序
        Arrays.sort(arr);
        // 然后开始随意交换，但是保证每个数距离不超过K
        // swap[i] == true, 表示i位置已经参与过交换
        // swap[i] == false, 表示i位置没有参与过交换
        boolean[] isSwap = new boolean[arr.length];
        for (int i = 0; i < arr.length; i++) {
            int j = Math.min(i + (int) (Math.random() * (K + 1)), arr.length - 1);
            if (!isSwap[i] && !isSwap[j]) {
                isSwap[i] = true;
                isSwap[j] = true;
                int tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
            }
        }
        return arr;
    }
}
```

### 最大线段重合问题

> 给定很多线段，每个线段都有数组[start,end]，表示线段开始位置和结束位置，左右都是闭区间
>
> - 线段开始和结束为止一定都是整数值
> - 线段重合区域的长度必须>=1
>
> 返回线段最多重合区域中，包含了几条线段

```java
public class MaxCoverLine {
    public static void main(String[] args) {
        //随机生成N个线段进行统计
        System.out.println(maxCover(generateLines(100, 0, 200)));
    }

    public static int maxCover(int[][] lineArray) {
        // 将所有线段按照起始索引排序
        Arrays.sort(lineArray, Comparator.comparingInt(a -> a[0]));

        PriorityQueue<Integer> heap = new PriorityQueue<>();
        // 定义重合最多的线段数
        int max = 0;
        // 从最小的线段开始，将小于star位置的元素弹出去，并且将end位置元素存添加到小根堆
        for (int[] line : lineArray) {
            while (!heap.isEmpty() && heap.peek() <= line[0]) {
                heap.poll();
            }
            heap.add(line[1]);
            // 永远返回最大的值
            max = Math.max(max, heap.size());
        }
        return max;
    }


    public static class Line {
        public int start;
        public int end;

        public Line(int s, int e) {
            start = s;
            end = e;
        }
    }

    public static int[][] generateLines(int N, int L, int R) {
        int size = (int) (Math.random() * N) + 1;
        int[][] ans = new int[size][2];
        for (int i = 0; i < size; i++) {
            int a = L + (int) (Math.random() * (R - L + 1));
            int b = L + (int) (Math.random() * (R - L + 1));
            if (a == b) {
                b = a + 1;
            }
            ans[i][0] = Math.min(a, b);
            ans[i][1] = Math.max(a, b);
        }
        return ans;
    }
}
```

## 加强堆

> Java提供的堆当某一个节点值变化了之后，是没有提供反向索引表,因此不知道这个元素当前处于数组中的哪个位置，如果要重新调整堆结构，只能遍历数组，找到这个变化的值所在的位置，然后才能决定能不能往上调整或者往下调整堆结构，这样做的时间复杂度是O(N)，因此，我们如果想要让堆具备这样即时调整堆结构的能力，需要手写提供反向索引表，当某个节点发送变化后，可以直接调用这个api进行堆结构调整，这样的时间复杂度是O(logN)

```java
public class StrengthenHeap<T> {
    private ArrayList<T> heap;
    private HashMap<T, Integer> indexMap;
    private int heapSize;
    private Comparator<T> comparator;

    public StrengthenHeap(Comparator<T> comparator) {
        this.comparator = comparator;
        this.heap = new ArrayList<>();
        this.indexMap = new HashMap<>();
        this.heapSize = 0;
    }

    public boolean isEmpty() {
        return heapSize == 0;
    }

    public int size() {
        return heapSize;
    }


    public boolean contains(T obj) {
        return indexMap.containsKey(obj);
    }

    public T peek() {
        return heap.get(0);
    }

    public void push(T obj) {
        heap.add(obj);
        indexMap.put(obj, heapSize);
        heapInsert(heapSize++);
    }

    public T pop() {
        T t = heap.get(0);
        // 获取顶部节点元素与最后节点护换
        swap(0, heapSize - 1);
        // 从反向查找表删除对应key
        indexMap.remove(t);
        // 从堆中移除最后一个元素
        heap.remove(--heapSize);
        // 重构堆结构，将换到顶部节点的元素下沉
        heapIfy(0);
        return t;
    }

    public void remove(T obj) {
        // 获取最后一个元素
        T t = heap.get(heapSize - 1);
        // 找到这个元素在反向查找表中的位置
        Integer idx = indexMap.get(obj);
        indexMap.remove(obj);
        heap.remove(--heapSize);
        // 处理非最后一个节点的元素
        if (obj != t) {
            // 将最后一个元素换到删除元素的位置顶替
            heap.set(idx, t);
            indexMap.put(t, idx);
            // 重调堆结构
            resign(t);
        }
    }

    public void resign(T t) {
        // 同时调用上升和下沉，必然会执行其中一个
        heapInsert(indexMap.get(t));
        heapIfy(indexMap.get(t));
    }

    private void heapInsert(int idx) {
        // 拿idx节点的值与它的父根进行比较，比父节点大则与父节点交换，依次向上对比，直到不大于父节点的值停止，或者移动到了整个堆的根节点停止
        while (comparator.compare(heap.get(idx), heap.get((idx - 1) / 2)) < 0) {
            swap(idx, (idx - 1) / 2);
            // idx跟随移动到对应节点位置
            idx = (idx - 1) / 2;
        }
    }

    private void swap(int idx, int i) {
        // 元素位置变动后，反向查找表也要随之变动
        T t1 = heap.get(idx);
        T t2 = heap.get(i);
        heap.set(idx, t2);
        heap.set(i, t1);
        indexMap.put(t2, idx);
        indexMap.put(t1, i);
    }

    public void heapIfy(int idx) {
        // 左分支位置
        // idx为0，左分支 0*2+1 = 1;
        // idx为1，左分支 1*2+1 = 3;
        // idx为2，左分支 1*2+1 = 5;
        int left = idx * 2 + 1;
        // 从idx位置不断下沉，当较大的分支没有idx位置的数大的时候，代表已经没有分支了，停止下沉
        while (left < heapSize) {
            // 确保右分支不越界 并且 将左右分支中稍大的一个数拿出来和目标值对比
            int largest = left + 1 < heapSize && comparator.compare(heap.get(left + 1), heap.get(left)) < 0 ? left + 1 : left;
            // 用这个较大节点值去对比父节点值，谁大把谁的下标给到largest
            largest = comparator.compare(heap.get(largest), heap.get(idx)) < 0 ? largest : idx;
            // 代表已经是三个节点中最大的值了，不需要下沉了
            if (largest == idx) {
                break;
            }
            // idx和较大分支的下标互换，将父节点数下沉
            swap(largest, idx);
            idx = largest;
            left = idx * 2 + 1;
        }
    }

    public List<T> getAll() {
        List<T> list = new ArrayList<>();
        for (T t : heap) {
            list.add(t);
        }
        return list;
    }
}
```

### 抽奖系统TopK得奖

> **给定一个整型数组，int[] arr; 和一个布尔类型数组，boolean[] op;**
>
> **两个数组一定等长，假设长度为N，arr[i]表示客户编号，op[i]表示客户操作**
>
> - arr=[3,3,1,2,1,2,5…]
> - op=[T,T,T,T,F,T,F...]
>
> 依次表示:
>
> 3用户购买了一件商品，
>
> 3用户购买了一件商品，
>
> 1用户购买了一件商品，
>
> 2用户购买了一件商品，
>
> 1用户退货了一件商品，
>
> 2用户购买了一件商品
>
> 5用户退货了一件商品…
>
> **一对arr[i]和op[i]就代表一个事件：用户号为arr[i]，op[i] == T就代表这个用户购买了一件商品op[i] == F就代表这个用户退货了一件商品**
>
> - 在每一个事件到来的时候都给**购买次数最多的前K名用户颁奖**
>
> - **每个事件发生后，你都需要一个得奖名单(得奖区)**
>
>   
>
> **得奖系统的规则:**
>
> - 如果某个用户购买商品数为0，但是又发生了退货事件，则认为该事件无效，得奖名单和之前事件时一致，比如例子中的5用户
>
> - 某用户发生购买商品事件，购买商品数+1，发生退货事件，购买商品数-1
>
> - 每次都是最多K个用户得奖，K也为传入的参数，如果根据全部规则，得奖人数确实不够K个，那就以不够的情况输出结果
>
> - 得奖系统分为得奖区和候选区，任何用户只要购买数>0，一定在这两个区域中的一个
>
> - 购买数最大的前K名用户进入得奖区，在最初时如果得奖区没有到达K个用户，那么新来的用户直接进入得奖区
>
> - 如果购买数不足以进入得奖区的用户，进入候选区
>
> - 如果候选区购买数最多的用户，已经足以进入得奖区该用户就会替换得奖区中购买数最少的用户(大于才能替换)如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户
>
> - 候选区和得奖区是两套时间8.因用户只会在其中一个区域，所以只会有一个区域的时间，
>
>   另一个没有从得奖区出来进入候选区的用户，得奖区时间删除，进入候选区的时间就是当前事件的时间(可以理解为arr[i]和op[i]中的i)
>
>   从候选区出来进入得奖区的用户，候选区时间删除，进入得奖区的时间就是当前事件的时间(可以理解为arr[i]和op[i]中的i)
>
> - 如果某用户购买数==0，不管在哪个区域都离开，区域时间删除，离开是指彻底离开，哪个区域也不会找到该用户，如果下次该用户又发生购买行为，产生>0的购买数，如果下次该用户又发生购买行为，产生>0的购买数会再次根据之前规则回到某个区域中，进入区域的时间重记

```java
package heap;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;

/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2024/4/19 2:18 AM
 */
public class PrizeDrawTopK {
    private HashMap<Integer, Customer> customers;
    // 得奖区
    private StrengthenHeap<Customer> prizeAreaHeap;
    // 候奖区
    private StrengthenHeap<Customer> prizeWaitingAreaHeap;
    // 得奖用户数
    private final int prizeLimit;

    public PrizeDrawTopK(int prizeLimit) {
        this.customers = new HashMap<>();
        this.prizeAreaHeap = new StrengthenHeap<>(new PrizeAreaComparator());
        this.prizeWaitingAreaHeap = new StrengthenHeap<>(new PrizeWaitingAreaComparator());
        this.prizeLimit = prizeLimit;
    }


    public static List<List<Integer>> topK(int[] arr, boolean[] op, int k) {
        List<List<Integer>> result = new ArrayList<>();
        PrizeDrawTopK drawTopK = new PrizeDrawTopK(k);
        for (int i = 0; i < arr.length; i++) {
            drawTopK.operation(i, arr[i], op[i]);
            // 公布所有得奖用户的id
            result.add(drawTopK.getAwardWinningUser());
        }
        return result;
    }

    private List<Integer> getAwardWinningUser() {
        List<Customer> customerList = prizeAreaHeap.getAll();
        List<Integer> result = new ArrayList<>();
        for (Customer customer : customerList) {
            result.add(customer.id);
        }
        return result;
    }

    // 处理购买事件
    public void operation(int time, int id, boolean buyOrRefund) {
        // 如果某个用户购买商品数为0，但是又发生了退货事件，则认为该事件无效
        if (!buyOrRefund && !customers.containsKey(id)) {
            return;
        }

        // 没有购买记录
        if (!customers.containsKey(id)) {
            customers.put(id, new Customer(id, 0, 0));
        }
        // 看操作是购买还是退货
        Customer customer = customers.get(id);
        if (buyOrRefund) {
            customer.buy++;
        } else {
            customer.buy--;
        }

        // 没消费则从参与名单中移除
        if (customer.buy == 0) {
            customers.remove(id);
        }

        if (!prizeWaitingAreaHeap.contains(customer) && !prizeAreaHeap.contains(customer)) {
            // 新用户进来如果得奖区没满则直接进得奖区,否则进入侯奖区
            if (prizeAreaHeap.size() < prizeLimit) {
                customer.enterTime = time;
                prizeAreaHeap.push(customer);
            } else {
                customer.enterTime = time;
                prizeWaitingAreaHeap.push(customer);
            }
        } else if (prizeWaitingAreaHeap.contains(customer)) {
            // 侯奖区用户如果购货为0则从侯奖区移除,否则重新调整侯奖区
            if (customer.buy == 0) {
                prizeWaitingAreaHeap.remove(customer);
            } else {
                prizeWaitingAreaHeap.resign(customer);
            }
        } else {
            // 得奖区用户如果退货为0则从得奖区移除,否则重新调整得奖区
            if (customer.buy == 0) {
                prizeAreaHeap.remove(customer);
            } else {
                prizeAreaHeap.resign(customer);
            }
        }
        // 侯奖区 <-> 得奖区
        this.prizeAreaHeapMove(time);
    }

    private void prizeAreaHeapMove(int time) {
        // 侯奖区没有参与用户
        if (prizeWaitingAreaHeap.isEmpty()) {
            return;
        }

        // 得奖区没参与满，侯奖区用户往得奖区移动
        if (prizeAreaHeap.size() < prizeLimit) {
            Customer customer = prizeWaitingAreaHeap.pop();
            customer.enterTime = time;
            prizeAreaHeap.push(customer);
        } else {
            // 候奖区排第一的比得奖区排第一的买的多
            if (prizeWaitingAreaHeap.peek().buy > prizeAreaHeap.peek().buy) {
                // 得奖区老用户到侯奖区
                Customer oldCustomer = prizeAreaHeap.pop();
                oldCustomer.enterTime = time;
                prizeWaitingAreaHeap.push(oldCustomer);

                // 侯奖区新用户到得奖区
                Customer newCustomer = prizeWaitingAreaHeap.pop();
                newCustomer.enterTime = time;
                prizeAreaHeap.push(newCustomer);
            }
        }

    }


    private static class Customer {
        public int id;
        public int buy;
        public int enterTime;

        public Customer(int id, int buy, int enterTime) {
            this.id = id;
            this.buy = buy;
            this.enterTime = enterTime;
        }
    }

    private static class PrizeAreaComparator implements Comparator<Customer> {
        @Override
        public int compare(Customer o1, Customer o2) {
            // 买的少排前面，买的一样多则最早买的排前面
            return o1.buy != o2.buy ? (o1.buy - o2.buy) : (o1.enterTime - o2.enterTime);
        }
    }

    private static class PrizeWaitingAreaComparator implements Comparator<Customer> {
        @Override
        public int compare(Customer o1, Customer o2) {
            // 买的多排前面，买的一样多则最早买的排前面
            return o1.buy != o2.buy ? (o2.buy - o1.buy) : (o1.enterTime - o2.enterTime);
        }
    }
```

