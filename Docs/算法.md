# 算法

## 时间复杂度

#### 什么是时间复杂度

> - 常数时间的操作：固定时间完成操作
>
>   - 常见算术运算（+、-、*、/、%）等
>   - 常见位运算（>>、>>>、<<、|、&、^）等
>   - 赋值、比较、自增、自减操作等
>
>   - 数组寻址
>
> - 非常数时间的操作：LinkedList寻址

#### 时间复杂度估算

> - 等差数列求和公式：aN²+bN+c
>
> - 当N->无穷，常数项可忽略，只看N的最高阶，比如一个算法时间复杂度为O(N³)，另一个算法时间复杂度为O(N²)，两个算法干的是同一件事的情况下 O(N²) 优于 O(N³) 

## 额外空间复杂度

> - 实现一个算法，需要开辟一些空间来支持算法流程
> - 必要的或者和实现目标有关的空间都不算做额外空间
>   - 作为输入参数的空间
>   - 作为输出结果的空间
> - 只需要开辟有限几个变量：额外空间复杂度为O(1)

## 常数项 

> - 当时间复杂度相同时，通过比常数项来判断算法的优劣
>
> - 常数项对比
>   - 放弃理论，生成随机数据进行测试（数据量*测试次数 以最终耗费时间做对比 ）

## 最优解

> - 时间复杂度尽可能的低
>
> - 尽可能优化空间 

## 常见时间复杂度排名

> O(1)       O(logN)  O(N)      O(N*logN)
>
> O(N²)     O(N³)  	   ···		O(N^K)
>
> O(2^N)  O(3^N)      ···         O(k^N)
>
> O(N!)

## 公共工具类

```java
package basic;

import java.util.Random;

/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/1 1:57 上午
 * @Description 公共工具类
 */
public class CommonUtils {
    public static final int[] ARR = {1, 4, 6, 2, 7, 2, 9, 8, 1, 0};

    /**
     * 替换数值
     *
     * @param arr 原数组
     * @param i   被替换元素
     * @param j   替换元素
     */
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    /**
     * 打印数组
     *
     * @param arr 数组
     */
    public static void printArray(int[] arr) {
        System.out.print("[");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i]);
            System.out.print(i < arr.length - 1 ? "," : "");
        }
        System.out.print("]\n");
    }

    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    public static int[] buildRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[maxSize];
        for (int i = 0; i < maxSize; i++) {
            arr[i] = new Random().nextInt(maxValue);
        }
        return arr;
    }

    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    private CommonUtils() {
    }
}

```

## 对数器

```java
import java.util.Arrays;

/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/1 3:22 上午
 * @Description 数组排序对数器
 */
public class DataTester {
    public static void main(String[] args) {
        int testCount = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean isSuccess = true;
        for (int i = 0; i < testCount; i++) {
            int[] arr = generateRandomArray(maxSize, maxValue);
            int[] arr1 = copyArray(arr);
            int[] arr2 = copyArray(arr);
            //需要测试的排序方法
            SelectionSort.sort(arr1);
            //用系统自带排序作为对数器和手写的排序方法做对比
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                for (int j = 0; j <arr.length ; j++) {
                    System.out.print(arr[j]+" ");
                }
                System.out.println();
                isSuccess = false;
                break;
            }
        }
        System.out.println(isSuccess?"Nice!":"Fucking fucked!");
    }

    public static int[] generateRandomArray(int maxSize, int maxValue) {
        // Math.random() ->  [0,1) 所有的小数，等概率返回一个
        // Math.random() * N -> [0,N) 所有小数，等概率返回一个
        // (int)(Math.random() * N) -> [0,N-1] 所有的整数，等概率返回一个
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }
}

```

## 异或运算

```java
int a=7;
int b=13;

//a ^ b = ?
//相同为0，不同为1
//a的二进制：0111
//b的二进制：1101
a ^ b = 10;
```

- 异或相加又称无进位相加

- 异或三大性质（技巧）

  > - 0 ^ N = N
  > - N ^ N = 0
  > - 有一批数做异或运算，同时满足交换律和结合律，得到的结果是同一个数
  >   - 偶数个1结果一定是0
  >   - 奇数个1结果一定是1

### 题记

- 两数值交换

  ```java
  int temp = 0;
  temp = a;
  a = b;
  b = temp；
    
  //以上代码可用异或代替
  1、a = a ^ b;
  //第一步：设 a=甲 ，b=乙 得：a = 甲 ^ 乙
  //将a = 甲 ^ 乙带入第二步中
  2、b = a ^ b;
  //第二步：b = 甲 ^ 乙 ^ 乙
  //由N ^ N = 0 （乙^乙=0）得：b = 甲 ^ 0 
  //由0 ^ N = N 得 b = 甲
  //将a = 甲^乙 ，b = 甲带入第二步中
  3、a = a ^ b;
  //第三步：a = 甲^乙^甲 = 甲^甲^乙 = 0^乙 = 乙
  //至此 a = 乙 ， b = 甲，完成了两数的互换
  //注意：此方法只可以用作两个不同区域的
  
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/3 12:47 上午
   * @Description 两值互换
   */
  public class TwoValueExchange {
      public static void main(String[] args) {
          twoValueExchange();
          twoValueExchangeForArray();
      }
  
      /**
       * 不用额外变量交换两个数的值
       */
      public static void twoValueExchange() {
          int a = 10;
          int b = 4;
          a = a ^ b;
          b = a ^ b;
          a = a ^ b;
          System.out.println("a=" + a);
          System.out.println("b=" + b);
      }
  
      /**
       * 不用额外变量交换数组中两个数的值
       */
      public static void twoValueExchangeForArray() {
          int[] arr = {1, 5, 3, 6};
          printArray(arr);
          //交换1、3位置的值
          arr[1] = arr[1] ^ arr[3];
          arr[3] = arr[1] ^ arr[3];
          arr[1] = arr[1] ^ arr[3];
          printArray(arr);
      }
    
     public static void printArray(int[] arr) {
          for (int i = 0; i < arr.length; i++) {
              System.out.print(arr[i] + " ");
          }
          System.out.println();
      }
  }
  ```



- 怎么把一个int类型的数，提取出二进制中最右侧的1来

  ```java
  // 运用 a & (-a) 技巧
  //设：a = 01101110010000
  //第一步：对a取反
  //得：~a = 10010001101111
  //根据 -a = ~a+1
  //得：-a = 10010001110000
  // a & (-a) = 00000000010000
  ```

  

- 找数

  - 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数？
  - 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数

  ```java
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/2 10:10 下午
   * @Description
   */
  public class EvenTimesOddTimes {
      public static void main(String[] args) {
          findOneKindOddNum();
          findTwoKindsOddNum();
      }
  
      //一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数？
      //利用性质三：
      // 有一批数做异或运算，同时满足交换律和结合律，得到的结果是同一个数
      // 偶数个1结果一定是0
      // 奇数个1结果一定是1
      public static void findOneKindOddNum() {
          int[] arr = {7, 4, 5, 7, 6, 7, 4, 5, 6};
          int exclusiveOr = 0;
          for (int i = 0; i < arr.length; i++) {
              exclusiveOr ^= arr[i];
          }
          // 44  55  66  777
          // 4^4=0   5^5=0   6^6=0   7^7=0  最终三个7消掉两个剩一个7直接返回
          System.out.println(exclusiveOr);
      }
  
      //一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数
      public static void findTwoKindsOddNum() {
          int[] arr = {7, 4, 5, 7, 6, 7, 5, 6};
          int exclusiveOr = 0;
          for (int i = 0; i < arr.length; i++) {
              exclusiveOr ^= arr[i];
          }
          //利用 -a = ~a+1 提取最右边的1
          int oneRight = exclusiveOr & (-exclusiveOr);
          int exclusiveOr2 = 0;
          for (int i = 0; i < arr.length; i++) {
              //4:0100   5:0101  6:0110  7:0111
              //只将最右边为1的数参与异或运算，与运算性质是只有两个位上都是1结果才为1，所以两个数与运算结果!=0的时候必然							 是两种数中的其中一个
              if ((arr[i] & oneRight) != 0) {
                  exclusiveOr2 ^= arr[i];
              }
          }
          //既然已经得到两种数中的其中一种，那么另外一种就直接用 exclusiveOr ^ exclusiveOr2 即可得出
          System.out.println(exclusiveOr2 + " , " + (exclusiveOr ^ exclusiveOr2));
      }
  }
  
  ```

  

- 一个数组中有一种数出现K次，其他数都出现了M次,已知M > 1，K < M，找到出现了K次的数,要求额外空间复杂度O(1)，时间复杂度O(N)

  ```java
  import java.util.HashMap;
  import java.util.HashSet;
  
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/3 3:08 上午
   * @Description
   */
  public class KM {
      public static void main(String[] args) {
          int kinds = 5;
          //设置需要生成几种数，至少两种数
          int maxValue = 100;
          int testTimes = 100000;
          for (int i = 0; i < testTimes; i++) {
              //-----------------------------------
              //以下代码保证了始终满足k<m条件
              int a = (int) (Math.random() * 9 + 1);
              int b = (int) (Math.random() * 9 + 1);
              int k = Math.min(a, b);
              int m = Math.max(a, b);
              if (k == m) {
                  m++;
              }
              //-----------------------------------
              int numKinds = (int) (Math.random() * kinds) + 2;
              int[] arr = randomArray(numKinds, maxValue, k, m);
              int res1 = test(arr, k);
              int res2 = findKTimesNum(arr, k, m);
              if (res1 != res2) {
                  System.out.println("出错了! " + res2);
              }
          }
          System.out.println("Nice!");
      }
  
      /**
       * 随机生成一个符合题意的数组
       *
       * @param maxValue
       * @param k
       * @param m
       * @return
       */
      public static int[] randomArray(int numKinds, int maxValue, int k, int m) {
          //首先设置一个数往数组里塞k次
          int kNum = randomNum(maxValue);
          //由k , m ，以及生成几种数决定数组长度
          // k+(numKinds-1)*m
          int[] arr = new int[k + (numKinds - 1) * m];
          int i = 0;
          for (; i < k; i++) {
              arr[i] = kNum;
          }
          //第一种数添加完成后减少一种数
          numKinds--;
          //生成的数要不能重复，所以建立hash表来记录已经存在的数
          HashSet<Integer> set = new HashSet<>();
          set.add(kNum);
          while (numKinds != 0) {
              int currNum = 0;
              do {
                  //如果hash表已经存在生成的数就重新生成;
                  currNum = randomNum(maxValue);
              } while (set.contains(currNum));
              set.add(currNum);
              numKinds--;
              //填充m个
              for (int j = 0; j < m; j++) {
                  //接着i的位置往后填充
                  arr[i++] = currNum;
              }
          }
          return upset(arr);
      }
  
  
      /**
       * 将规律的数组打乱
       *
       * @param arr
       * @return
       */
      public static int[] upset(int[] arr) {
          for (int i = 0; i < arr.length; i++) {
              int j = (int) (Math.random() * arr.length);
              int temp = arr[i];
              arr[i] = arr[j];
              arr[j] = temp;
          }
          return arr;
      }
  
      /**
       * 随机生成一个 -num ~ num的数
       *
       * @param range
       * @return
       */
      public static int randomNum(int range) {
          return (int) (Math.random() * range + 1) - (int) (Math.random() * range + 1);
      }
  
  
      /**
       * 寻找出现k次的数
       *
       * @param arr
       * @param m
       * @return
       */
      public static int findKTimesNum(int[] arr, int k, int m) {
          //设k=3;M=5  满足M > 1，K < M
          int[] initArr = new int[32];
          for (int num : arr) {
              for (int j = 0; j < initArr.length; j++) {
                  //&1的含义：j=0 时，num=0011 ，0011 & 1 = 1 initArr[0]+=1 在initArr[0]这个位置上记录一次
                  //j = 1 时，num >> 1 = 0001 ，0001 & 1 = 1 initArr[1]+=1 initArr[1]记录一次
                  //j = 2 时，num >> 2 = 0000 , 0000 & 1 = 0 initArr[1]+=0 相当于initArr[2]位置不记录
                  //以此类推，相当于从最低位到最高位挨个记录对应位置为1的次数
                  initArr[j] += (num >> j) & 1;
              }
          }
  
          //new一个32位int类型变量，遍历记录完各个数出现次数的initArr数组,用每个位上的次数对K和M取模，结果为1的说明这个        					 数在第i位上为1
          //逐位往new的变量里面设置值，最终得到一个数
          int result = 0;
          for (int i = 0; i < initArr.length; i++) {
              if (initArr[i] % m != 0) {
                  //在第几位上有1就将result的第几位设置成1
                  // 如：第2位上有1时 1(0001)<<2 = 0100 ；0100 | result(0000) = 0100
                  //    第3位上有1时 1(0001)<<3 = 1000 ；1000 | result(0100) = 1100
                  // 得到最终result为1100 (此结果为举例结果，非题解)
                  result |= (1 << i);
              }
          }
          return result;
      }
  
      /**
       * 对数器遍历计数法 百分百正确的结果
       *
       * @param arr
       * @param k
       * @return
       */
      public static int test(int[] arr, int k) {
          HashMap<Integer, Integer> map = new HashMap<>();
          for (int num : arr) {
              if (map.containsKey(num)) {
                  map.put(num, map.get(num) + 1);
              } else {
                  map.put(num, 1);
              }
          }
          for (int num : map.keySet()) {
              if (map.get(num) == k) {
                  return num;
              }
          }
          return -1;
      }
  }
  ```
  
- 一个数组中有一种数出现K次，其他数都出现了M次,已知M > 1，K < M，找到出现了K次的数,并且当这个数没有出现K次的时候返回-1要求额外空间复杂度O(1)，时间复杂度O(N)

  ```java
  //findKTimesNum方法改写
  public static int findKTimesNum(int[] arr, int k, int m) {
    //设k=3;M=5  满足M > 1，K < M
    int[] initArr = new int[32];
    for (int num : arr) {
      for (int j = 0; j < initArr.length; j++) {
        //&1的含义：j=0 时，num=0011 ，0011 & 1 = 1 initArr[0]+=1 在initArr[0]这个位置上记录一次
        //j = 1 时，num >> 1 = 0001 ，0001 & 1 = 1 initArr[1]+=1 initArr[1]记录一次
        //j = 2 时，num >> 2 = 0000 , 0000 & 1 = 0 initArr[1]+=0 相当于initArr[2]位置不记录
        //以此类推，相当于从最低位到最高位挨个记录对应位置为1的次数
        initArr[j] += (num >> j) & 1;
      }
    }
  
    //new一个32位int类型变量，遍历记录完各个数出现次数的initArr数组,用每个位上的次数对K和M取模，结果为1的说明这个数在第i位上为1
    //逐位往new的变量里面设置值，最终得到一个数
    int result = 0;
    for (int i = 0; i < initArr.length; i++) {
      if (initArr[i] % m == 0) {
        continue;
      }
      if (initArr[i] % m == k) {
        result |= (1 << i);
      } else {
        result = -1;
      }
    }
  
    //解决0没有出现k次的情况
    if (result==0){
      int count = 0;
      for (int num:arr) {
        if (num==0){
          count++;
        }
      }
      if (count!=k){
        return -1;
      }
    }
    return result;
  }
  
  
  
  //randomArray方法改写
  public static int[] randomArray(int numKinds, int maxValue, int k, int m) {
    //首先设置一个数往数组里塞k次
    int kNum = randomNum(maxValue);
  
    //使生成k次的几率为50%，50%几率随机生成一个比m小的数;
    int times = Math.random()<0.5?k: (int) ((Math.random() * (m - 1)) + 1);
    int[] arr = new int[times + (numKinds - 1) * m];
    int i = 0;
    for (; i < times; i++) {
      arr[i] = kNum;
    }
  
    //第一种数添加完成后减少一种数
    numKinds--;
    //生成的数要不能重复，所以建立hash表来记录已经存在的数
    HashSet<Integer> set = new HashSet<>();
    set.add(kNum);
    while (numKinds != 0) {
      int currNum = 0;
      do {
        //如果hash表已经存在生成的数就重新生成;
        currNum = randomNum(maxValue);
      } while (set.contains(currNum));
      set.add(currNum);
      numKinds--;
      //填充m个
      for (int j = 0; j < m; j++) {
        //接着i的位置往后填充
        arr[i++] = currNum;
      }
    }
    return upset(arr);
  }
  
  
  //对数器改写
  public static void main(String[] args) {
    int kinds = 5;
    //设置需要生成几种数，至少两种数
    int maxValue = 100;
    int testTimes= 100000;
  
    for (int i = 0; i < testTimes; i++) {
      //-----------------------------------
      //以下代码保证了始终满足k<m条件
      int a = (int) (Math.random() * 9 + 1);
      int b = (int) (Math.random() * 9 + 1);
      int k = Math.min(a, b);
      int m = Math.max(a, b);
      if (k == m) {
        m++;
      }
      //-----------------------------------
      int numKinds = (int) (Math.random() * kinds) + 2;
      int[] arr = randomArray(numKinds, maxValue, k, m);
      int res1 = test(arr, k);
      int res2 = findKTimesNum(arr, k, m);
  
      if (res1 != res2) {
        System.out.println("出错了! "+res1 +" "+ res2);
      }
    }
    System.out.println("Nice!");
  }
  ```
  
  

## 基础数据结构

### 链表

#### 单向链表

#### ![image-20211208204231073](https://article.biliimg.com/bfs/article/08baf2536d0f6968794ae77f742f6cf7dbe22392.png)

##### 节点结构

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/5 9:59 上午
 * @Description 单向链表节点结构
 */
public class Node<T> {
    public T value;
    public Node<T> next;

    public Node(T value) {
        this.value = value;
    }
}
```

##### 题记

###### 单链表反转

- 思路图解

###### ![image-20211213030503316](https://article.biliimg.com/bfs/article/1ee4c9b56b024a4315b7d5a1b1f143d5ae7043dd.png)

- 关键代码

  ```java
  //a -> b -> c -> null
  //null <- a <- b <- c
  public static Node reverse(Node head) {
    Node pre = null;
    Node next = null;
    while (head != null) {
      //提前记录next节点
      next = head.next;
      //将头结点的下一个节点指向Pre
      head.next = pre;
      //pre移动到当前头节点位置
      pre=head;
      //头结点移动到提前记录的next位置
      head=next;
    }
    //当head为null时说明已经到头了,此时应该返回pre所在位置的节点作为头结点
    return pre;
  }
  ```
  
  

####  

#### 双向链表

#### <img src="https://article.biliimg.com/bfs/article/a88061a87d775db4ac693b7d9fe5a6372249e6c6.png" alt="image-20211208203724483" style="zoom:100%;" />

##### 节点结构

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/5 10:35 上午
 * @Description
 */
public class DoubleNode<T> {
    public T value;
    public DoubleNode<T> pre;
    public DoubleNode<T> next;

    public DoubleNode(T value) {
        this.value = value;
    }
}
```

##### 题记

###### 双向链表反转 

- 思路图解

  ![image-20211213030331079](https://article.biliimg.com/bfs/article/e23d0a0e8b486d8e65a38d102dedd72d4165a9b3.png)

- 关键代码

  ```java
  public static DoubleNode<Integer> reverse(DoubleNode<Integer> head) {
    DoubleNode<Integer> pre = null;
    DoubleNode<Integer> next = null;
    while (head != null) {
  		//首先记录next节点
      next = head.next;
      //将当前头节点的下一个节点指向当前pre所在的地址
      head.next = pre;
      //将当前头结点的上一个节点指向原来next的地址
      head.last = next;
      //将pre标志移动到当前头的位置
      pre = head;
      //将next变为头结点
      head = next;
    }
    //当头结点到达Null的时候说明pre是最后一个有效头节点
    return pre;
  }
  ```

###### K个节点的组内逆序调整

>   - 给定一个单链表的头节点head，和一个正数k，实现k个节点的小组内部逆序，如果最后一组不够k个就不调整
>
>     - 例子: 调整前：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8，k = 3
>
>       ​		  调整后：3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8

- 思路图解

  ![image-20211218212040853](https://article.biliimg.com/bfs/article/b25bfcc2c554827e34406b9fcc3c45aebaa3eebb.png)

- 关键代码

  ```java
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/16 8:34 下午
   * @Description Definition for singly-linked list.
   * public class ListNode {
   * int val;
   * ListNode next;
   * ListNode() {}
   * ListNode(int val) { this.val = val; }
   * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
   * }
   * 力扣原题：https://leetcode-cn.com/problems/reverse-nodes-in-k-group/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china
   */
  public class ReverseKGroup<T> {
      public ListNode reverseKGroup(ListNode head, int k) {
          ListNode start = head;
          ListNode groupEnd = findGroupEnd(start, k);
          //凑不够一组直接返回当前头节点
          if (groupEnd == null) {
              return head;
          }
          //第一组满足K个
          head = groupEnd;
          reverse(start, groupEnd);
          //上一组的最后一个节点（其实就是上一组的开始节点，经过反转后成为最后一个节点）
          ListNode lastEnd = start;
          //当上一组的最后一个节点不指向Null的时候（如果最后没凑够一组也是会返回Null的）
          while (lastEnd.next != null) {
              //将上一组最后一个节点的下一个节点设置为下一组的开始节点
              start = lastEnd.next;
              groupEnd = findGroupEnd(start, k);
              if (groupEnd == null) {
                  return head;
              }
              reverse(start, groupEnd);
              //上一组反转后的最后一个节点指向这一组的结束节点
              lastEnd.next = groupEnd;
              //将下一组的开始节点设置为反转后的最后一个节点
              lastEnd = start;
          }
          return head;
      }
  
      /**
       * 组内反转
       *
       * @param start
       * @param groupEnd
       * @return
       */
      public void reverse(ListNode start, ListNode groupEnd) {
          ListNode pre = null;
          ListNode curr = start;
          //代名词为：本组反转操作的最后标志位，实际为下一组的开始节点
          ListNode operationEnd = groupEnd.next;
          //如果Curr标志位跳到操作终止节点代表本组反转已经结束
          while (curr != operationEnd) {
              ListNode next = curr.next;
              curr.next = pre;
              pre = curr;
              curr = next;
          }
          //本组的开始节点(反转后应该是最后一个节点)，指向下一组的开始节点
          start.next = operationEnd;
      }
  
      /**
       * 找每组最后一个节点
       *
       * @param start
       * @param k
       * @return
       */
      public ListNode findGroupEnd(ListNode start, int k) {
          while (--k != 0 && start != null) {
              start = start.next;
          }
          return start;
      }
  
  
      public class ListNode {
          int val;
          ListNode next;
  
          ListNode() {
          }
  
          ListNode(int val) {
              this.val = val;
          }
  
          ListNode(int val, ListNode next) {
              this.val = val;
              this.next = next;
          }
      }
  }
  
  ```

###### 两个链表相加

> 给定两个链表的头节点head1和head2，认为从左到右是某个数字从低位到高位，返回相加之后的链表
>
> - 例子     4 -> 3 -> 6 -> 9        3 -> 5 -> 4
>
>   返回     7 -> 8 -> 0 -> 0 -> 1
>
>   解释     9634 + 453 = 10087

- 思路图解

  ![image-20211222014356479](https://article.biliimg.com/bfs/article/5b19316cbcdba92f65e5efb6e31161a07a519276.png)

- 关键代码

  ```java
  //长短链表题
  //共分为三阶段：
  //一阶段：长链表有，短链表有
  //二阶段：长链表有，短链表无
  //三阶段：长链表无，短链表无
  
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/20 10:57 下午
   * @Description 两链表相加
   * @leetcode：https://leetcode.com/problems/add-two-numbers/
   */
  public class AddTwoNumbers {
      public ListNode addTwoNumbers(ListNode head1, ListNode head2) {
          int len1 = calcLength(head1);
          int len2 = calcLength(head2);
          ListNode longNode = len1 >= len2 ? head1 : head2;
          ListNode shortNode = longNode == head1 ? head2 : head1;
          ListNode currL = longNode;
          ListNode currS = shortNode;
          ListNode last = null;
          int carry = 0;
          int nodeSum = 0;
          //一阶段：长短链表都有的情况 直接判断短链表是否为NULL得知是否一阶段结束
          while (currS != null) {
              nodeSum = currL.val + currS.val + carry;
              currL.val = nodeSum % 10;
              carry = nodeSum / 10;
              last = currL;
              currL = currL.next;
              currS = currS.next;
          }
  
          //二阶段，长链表有，短链表无
          while (currL != null) {
              nodeSum = currL.val + carry;
              currL.val = nodeSum % 10;
              carry = nodeSum / 10;
              last = currL;
              currL = currL.next;
          }
  
          //三阶段：长短链表都无，校验进位信息决定是否补新节点
          if (carry != 0) {
              last.next = new ListNode(1);
          }
          return null;
      }
  
      /**
       * 计算链表长度
       *
       * @param node
       * @return
       */
      public int calcLength(ListNode node) {
          int length = 0;
          while (node != null) {
              length++;
              node = node.next;
          }
          return length;
      }
  
      public class ListNode {
          int val;
          ListNode next;
  
          ListNode() {
          }
  
          ListNode(int val) {
              this.val = val;
          }
  
          ListNode(int val, ListNode next) {
              this.val = val;
              this.next = next;
          }
      }
  }
  ```

  

###### 两个有序链表的合并

- 思路图解

  ![image-20211225114944761](https://article.biliimg.com/bfs/article/0e3a7282524d7bfa792a1fddd0188cbc1e6af2db.png)

- 关键代码

  ```java
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/22 8:35 下午
   * @Description 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
   * @leetcode：https://leetcode-cn.com/problems/merge-two-sorted-lists/
   */
  public class MergeTwoLists {
      public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
          if (list1 == null || list2 == null) {
              return list1 == null ? list2 : list1;
          }
  
          //找到最小的作为头节点（升序链表）
          ListNode head = list1.val <= list2.val ? list1 : list2;
          ListNode pre = head;
          ListNode curr1 = head.next;
          ListNode curr2 = head == list1 ? list2 : list1;
          //两链表都有节点
          while (curr1 != null && curr2 != null) {
              if (curr1.val <= curr2.val) {
                  pre.next = curr1;
                  curr1 = curr1.next;
              } else {
                  pre.next = curr2;
                  curr2 = curr2.next;
              }
              pre = pre.next;
          }
          //仅剩一个链表有节点
          pre.next = curr1 == null ? curr2 : curr1;
          return head;
      }
  
  
      public class ListNode {
          int val;
          ListNode next;
  
          ListNode() {
          }
  
          ListNode(int val) {
              this.val = val;
          }
  
          ListNode(int val, ListNode next) {
              this.val = val;
              this.next = next;
          }
      }
  }
  ```
  
  

## 栈

- 数据先进后出（子弹匣）

### 手写栈

### ![image-20211209030917929](https://article.biliimg.com/bfs/article/e7d844430f30781b705dffb116a1db29e570d16c.png)

#### 单链表实现

##### 思路图解

![image-20211213030758613](https://article.biliimg.com/bfs/article/1abca091465ab701f3a2244758b35846997aa956.png)

##### 关键代码

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/9 2:45 上午
 * @Description
 */
public class MyStack<T> {
    private Node<T> head;
    private int size;

    public int size() {
        return this.size;
    }

    public Boolean isEmpty() {
        return size == 0;
    }

    /**
     * 压栈
     * @param value
     */
    public void push(T value) {
        //遵循队列先进后出
        //从头节点开始弹出，符合队列先进后出机制
        Node<T> currNode = new Node<>(value);
        if (head != null) {
            currNode.next = head;
        }
        head = currNode;
        size++;
    }

    /**
     * 弹栈
     * @return
     */
    public T pop() {
        T val = null;
        if (head != null) {
            val = head.value;
            head = head.next;
            size--;
        }
        return val;
    }

    /**
     * 查看栈顶值
     * @return
     */
    public T peek() {
        return head == null ? null : head.value;
    }
}

```

- 双向链表实现

  ```java
  
  ```

- 数组实现

  ```java
  
  ```

### 题记

- 实现一个特殊的栈，在基本工能的基础上，再实现返回栈中最小元素的功能

  - pop、push、getMin操作的时间复杂度都是O(1)
  - 设计的栈类型可以使用现成的栈结构

  ```java
  //建两个栈，一个数据栈，一个最小值栈，每往数据栈里压一个值，同步往最小值栈里压一个值
  //最小值呀栈的情况为：当最小值栈为空的时候，同步压数据栈相同的数，当最小值栈里有内容的时候
  //数据栈当前压栈的值跟最小值栈里栈顶的值比较，如果比最小值栈顶值小就同步压入当前数据栈栈顶的值，
  //如果比最小值栈顶大就重复压入当前最小值栈顶的值
  ```

  



## 队列

- 数据先进先出（排队）

### 手写队列

#### 主要功能

![image-20211209030950177](https://article.biliimg.com/bfs/article/f65975718a6258df3b5fb7be7b62c80e04fcf2ee.png)

#### 单链表实现

##### 思路图解

![image-20211213221518395](https://article.biliimg.com/bfs/article/fcf407dccaab1c1a44ad1ae10c288bab45117888.png)

##### 关键代码

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/9 12:05 上午
 * @Description
 */
public class MyQueue<T> {
    private Node<T> head;
    private Node<T> tail;
    private int size;


    public int size() {
        return this.size;
    }

    public Boolean isEmpty() {
        return size == 0;
    }

    public void offer(T value) {
        //遵循队列先进先出
        //从头节点开始弹出，符合队列先进先出机制
        Node<T> currNode = new Node<>(value);
        if (tail == null) {
            head = currNode;
            tail = currNode;
        } else {
            tail.next = currNode;
            tail = currNode;
        }
        size++;
    }

    public T poll() {
        T value = null;
        if (head != null) {
            //获取当前头结点的值
            value = head.value;
            //让当前头节点的下一个节点成为新的头节点
            head = head.next;
            //每弹出一个值size同步递减
            size--;
        }
        if (head==null){
            //说明没有值了，保持头尾节点一致;
            tail = null;
        }
        return value;
    }

    public T peek() {
        T value = null;
        if (head != null) {
            //获取当前头结点的值
            value = head.value;
        }
        return value;
    }

    public MyQueue() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
}
```

### 手写双端队列

#### 主要功能

![image-20211213025804017](https://article.biliimg.com/bfs/article/b6799f424256ea185506b76f1b68b8f8f8eb6da1.png)

#### 思路图解

![image-20211213221552527](https://article.biliimg.com/bfs/article/68f719bd6947787938aca4b0017366070db8302f.png)

#### 关键代码

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/13 1:34 上午
 * @Description
 */
public class MyDeque<T> {
    private DoubleNode<T> head;
    private DoubleNode<T> tail;
    private int size;

    public void pushHead(T value) {
        DoubleNode<T> curr = new DoubleNode<>(value);
        if (head == null) {
            head = curr;
            tail = curr;
        } else {
            head.last = curr;
            curr.next = head;
            head = curr;
        }
        size++;
    }

    public void pushTail(T value) {
        DoubleNode<T> curr = new DoubleNode<>(value);
        if (head == null) {
            head = curr;
            tail = curr;
        } else {
            tail.next = curr;
            curr.last = tail;
            tail = curr;
        }
        size++;
    }

    public T pollHead() {
        T value = null;
        if (head == null) {
            return value;
        }
        value = head.value;
        if (head == tail) {
            head = null;
            tail = null;
        } else {
            head = head.next;
            head.last = null;
        }
        size--;
        return value;
    }

    public T pollTail() {
        T value = null;
        if (tail == null) {
            return value;
        }
        value = tail.value;
        if (tail == head) {
            tail = null;
            head = null;
        } else {
            tail = tail.last;
            tail.next = null;
        }
        size--;
        return value;
    }

    public T peekHead() {
        T value = null;
        if (!isEmpty()) {
            value = head.value;
        }
        return value;
    }

    public T peekTail() {
        T value = null;
        if (!isEmpty()) {
            value = tail.value;
        }
        return value;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return size;
    }

    public MyDeque() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
}

```



### 题记

- 如何用栈结构实现队列结构

  ```java
  //由于栈先进后出，队列先进先出，所以需要两个栈来拼出一个队列，先压满第一个栈，然后逐个弹栈往第二个栈里压，压完第二个栈就相当于出栈顺序跟队列保持一致了，相当于将第一个栈里的数据进行了一个反转
  //push栈没倒完数据。pop栈不能取数据
  //pop栈没取完，push栈不能倒数据
  ```

- 如何用队列结构实现栈结构

  ```java
  //由于队列先进先出 栈先进后出，每次像栈那样去取最顶（后）的值，所以建两个队列，要去1队列的最后进入的值时，把这个值前面的所有值全部pop到队列2，如果要在队列2取新进入的值，则将队列2要取的值前面所有值重新pop到队列1，只留要取的那个值，这样来回pop 就可以想栈那样push想要的值 
  ```

## 递归

- 任何递归都可以转换为非递归 

### 系统栈

```java

```

### Master公式

- 形如 T(N) = a*T(N/b)+O(N^d) 其中的a、b、d都是常数的递归函数，可以直接通过Master公式来确定时间复杂度

  1、如果log(b,a) < d,复杂度为O(N^d)

  2、如果log(b,a) > d,复杂度为O(N^log(b,a))

  3、如果log(b,a) ==d,复杂度为O(N^d*logN)

  ```java
  T(N) = 2*T(N/2)+O(1); 
  a=2,b=2,d=0; log(2,2)=1=d; 
  满足log(b,a)==d,复杂度为O(N^d*logN)
  ```

- 不属于T(N) = a*T(N/b)+O(N^d) 其中的a、b、d都是常数的递归函数这种形式的复杂度计算

  ```java
  递归取最大值时先取左边2/3再取右边2/3，这种情况下就是有一部分是重合的
  此时T(N) = 2*T(N/3/2)+O(1);
  a=2,b=3/2,d=0
  复杂度为 O(N^log(3/2,2))
  ```

## Hash表(HashMap)

- 基础类型和非基础类型底层的区别
  - 基础类型根据实际情况开辟具体空间进行存储，哪怕需要开辟的空间非常大
  - 非基础类型会将引用的类型的内存地址，8字节     
- Hash表中的原生基础类型都是按值传递 (其中包括String类型)，如果是自定义的类型（非原生自带的）按引用传递

## 有序表(TreeMap)

- 有序表可用（红黑树、avl树，sb树、跳表）实现

- Java中TreeMap使用红黑树实现

- 时间复杂度为O(logN)

-  有序表比Hash表多且强大的功能

  ```java
  TreeMap<Integer,String> treeMap = new TreeMap<>();
  //最小key
  System.out.println(treeMap.firstKey());
  //最大key
  System.out.println(treeMap.lastKey());
  //<=4 查找离4最近的key
  System.out.println(treeMap.floorKey(4));
  //>=4 查找离4最近的key
  System.out.println(treeMap.ceilingKey(4));
  ```

- 有序表对非基础类型进行排序时需要自己传一个比较器定义排序规则

## 归并排序

> MergeSort：时间复杂度为O(N*logN)

### 归并逻辑

```java

/**
 * <p>
 * <b>归并排序</b>
 * </p >
 *
 * @author : RhysNi
 * @version : v1.0
 * @date : 2023/9/18 15:28
 * @CopyRight :　<a href="https://blog.csdn.net/weixin_44977377?type=blog">倪倪N</a>
 */
public class MergeSortMain {
    public static void main(String[] args) {
        int testTime = 500_000;
        int maxSize = 100;
        int maxValue = 100;

        System.out.println("--- MergeSort test start ---");
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = CommonUtils.buildRandomArray(maxSize, maxValue);
            int[] arr2 = CommonUtils.copyArray(arr1);

            // 递归法
            MergeSortByRecursion.mergeSort(arr1);
            // 步长法
            MergeSortNonRecursion.mergeSort(arr2);

            if (!CommonUtils.isEqual(arr1, arr2)) {
                System.out.println("MergeSort test error");
                printArray(arr1);
                printArray(arr2);
            }
        }
        System.out.println("--- MergeSort test success ---");
    }


    public static void merge(int[] arr, int startIndex, int mid, int endIndex) {
        // 辅助数组用于最终合并数据，长度为起始索引到结束索引的所有元素的个数
        int[] tempArr = new int[endIndex - startIndex + 1];
        int i = 0;
        int startIndexL = startIndex;
        int startIndexR = mid + 1;

        // 越界判断，保证左右两部分都没有越界
        while (startIndexL <= mid && startIndexR <= endIndex) {
            // 通过指针移动使左右两边的元素一一比较，哪边小就取那边，相等则默认取左边（实际取哪边都一样）
            tempArr[i++] = arr[startIndexL] <= arr[startIndexR] ? arr[startIndexL++] : arr[startIndexR++];
        }

        //当左边越界,右边没越界时，放入右组元素
        while (startIndexR <= endIndex) {
            tempArr[i++] = arr[startIndexR++];
        }
        //当右边越界，左边没越界时，放入左组元素
        while (startIndexL <= mid) {
            tempArr[i++] = arr[startIndexL++];
        }

        // 将最终排序完成的数组传递给原数组
        for (int j = 0; j < tempArr.length; j++) {
            // 从最新的起始索引开始往后
            arr[startIndex + j] = tempArr[j];
        }
    }
}
```

### 递归写法

```java
/**
 * <p>
 * <b>递归写法</b>
 * </p >
 *
 * @author : RhysNi
 * @version : v1.0
 * @date : 2023/9/18 20:10
 * @CopyRight :　<a href="https://blog.csdn.net/weixin_44977377?type=blog">倪倪N</a>
 */
public class MergeSortByRecursion {
    public static void mergeSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        // 对数从第一个元素到最后一个元素进行归并排序
        process(arr, 0, arr.length - 1);
    }

    private static void process(int[] arr, int startIndex, int endIndex) {
        // 开始到结束只存在一个数，默认有序，直接返回
        if (startIndex == endIndex) {
            return;
        }

        // 开始到结束存在多个元素的取中点，先对左边递归排序，再对右边递归排序，最终进行合并
        // 如果 数组长度为15，起始索引从0开始。对应最大索引为arr[14], 14>>1 = 1110 >> 1 = 0111 = 7
        // 如果 数组长度为16，起始索引从0开始。对应最大索引为arr[15], 15>>1 = 1111 >> 1 = 0111 = 7
        int mid = startIndex + ((endIndex - startIndex) >> 1);
        // 作用相同，但上面写法更安全，因为如果数组长度非常大，startIndex + endIndex 可能越界
        // int mid = (startIndex + endIndex) / 2;

        // 递归开始直到完全排序完成
        process(arr, startIndex, mid);
        process(arr, mid + 1, endIndex);
        MergeSortMain.merge(arr, startIndex, mid, endIndex);
    }
}

```

### 步长写法

```java
/**
 * <p>
 * <b>非递归写法-计算步长</b>
 * </p >
 *
 * @author : RhysNi
 * @version : v1.0
 * @date : 2023/9/18 20:11
 * @CopyRight :　<a href="https://blog.csdn.net/weixin_44977377?type=blog">倪倪N</a>
 */
public class MergeSortNonRecursion {
    public static void mergeSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }

        // 定义一个步长，根据步长的变化控制每次参与排序的元素数量
        // 假设又数组[8，1，7，6，2]
        // step = 1 --- 则每次只有1个元素为一组参与排序，即 [8] vs [1] -- [7]vs [6] -- [2] -- 得[1,8,6,7,2]
        // step = 2 --- 则每次有2个元素为一组参与排序，即 [1,8] vs [6,7] -- [9] -- 得[1,6,7,8,2]
        // step = 4 --- 则每次有4个元素为一组参与排序，如果有凑不足4个元素为一组的就直接参与merge, 即 [1,6,7,8] vs [2] -- 得[1,2,6,7,8]
        int step = 1;

        // 最大边界为数组长度
        int endIndex = arr.length;

        // 边界判断 :
        // 有这么一种情况，假设数组最大长度是15
        // 当 step = 8 时候，左右两组得元素索引都还在边界范围内
        // 当 step = 16 时。已经比原数组长度大了。当获取arr[15]的时候就越界了，我们最大数组长度是15，对应的最大索引即为arr[14]
        // 还有一种情况 ，假设数组最大长度是16
        // 当 step = 8 时候，左右两组得元素索引都还在边界范围内
        // 当 step = 16 时, 步长和数组最大长度相等时则不用进行排序了，说明该排序的都已经排好了，右组没有多余的元素需要进行排序了。
        // 所以如果步长*2 >= 边界最大长度直接结束了
        while (step < endIndex) {
            // 左组起始索引从0开始
            int startIndexL = 0;
            while (startIndexL < endIndex) {
                // 初始化中位索引
                int midIndex = 0;
                // 确定左组边界
                if (endIndex - startIndexL >= step) {
                    // 当边界索引-左组起始索引 >= 步长时:
                    // 代表左组能够凑到步长数对应的元素个数或者刚好和步长相等,则可定中位索引为：左组起始索引+步长数-1
                    // 假设数组长度为15：endIndex=15 -- startIndexL=0 -- step=8 -- 得endIndex-startIndexL=15 -- 因此midIndex=0+8-1=arr[7]
                    // 假设数组长度为16：endIndex=16 -- startIndexL=0 -- step=16 -- 得endIndex-startIndexL=16 -- 因此midIndex=0+16-1=arr[15]
                    midIndex = startIndexL + step - 1;
                } else {
                    // 假设数组长度为15：endIndex=15 -- startIndexL=0 -- step=16 -- 得endIndex-startIndexL=15 -- 因此midIndex=0+16-1=arr[15]
                    // 但是我们数组最大长度为15，对应的最大索引应该是arr[14]，只有15个数，凑不够16个数为一组
                    // 如果使用arr[15]则会发生越界，因此我们定义midIndex为最大索引即可，有多少算多少
                    midIndex = endIndex - 1;
                }

                // 如果左组长度刚好为整个数组的长度，说明该排序的都排好了，没有右组则无需排序
                if (midIndex == endIndex - 1) {
                    break;
                }

                // 有右组的情况下先确定右组边界
                // 初始化右组边界
                int endIndexR = 0;
                // 因为刚才我们确定了midIndex的位置：在 startIndexL + step - 1位置上
                // - 假设数组长度为16 -- step=8：midIndex=在startIndexL + step - 1位置上=arr[7] -- endIndex - 1 - midIndex = 15-7=8
                //   因此刚好凑够一组与步长相等个数的元素，则右组边界定为中位索引+步长的值
                if (endIndex - 1 - midIndex >= step) {
                    endIndexR = midIndex + step;
                } else {
                    // - 假设数组长度为15 -- step=8：midIndex在startIndexL + step - 1位置上=arr[7] -- endIndex-1-midIndex = 14-7=7
                    //   因此凑不够8个元素的右组，直接以最大索引作为右组最大边界
                    endIndexR = endIndex - 1;
                }

                // 提供排序数组，左组开始索引，中位索引，和右组边界索引进行归并排序
                MergeSortMain.merge(arr, startIndexL, midIndex, endIndexR);

                // 如果上一组的右组边界刚好等于数组最大索引则无需继续排序
                // 如果仍然存在其他元素可进行排序，则需要将指针移动到下一组的左组起始索引位置,即endIndexR + 1的位置
                if (endIndexR == endIndex - 1) {
                    break;
                } else {
                    startIndexL = endIndexR + 1;
                }
            }
            // 控制步长为 2^N并且当步长 > 数组一半长度时不用继续增加步长
            // 假设数组长度15 ， endIndex / 2 = 7
            // 因此当 step=1 时候 下一次排序则需要将步长调整为 step=2...直到step=8时，此时步长超过中位索引长度，意味着本次排序完成将没有多余元素参与排序
            // 如果将步长调整为16 即step=16时，已经超过数组最大长度
            // 同理：步长==中位索引长度也是一样不需要继续调整步长
            if (step > endIndex / 2) {
                break;
            } else {
                step *= 2;
            }
        }
    }
}
```

