# 算法

## 时间复杂度

>一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或「时间频度」。记为T(
n)。时间频度T(n)中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。算法的时间复杂度也就是算法的时间度量，记作：T(n) = O(f(n))
。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称「时间复杂度」。这种表示方法我们称为「 大O符号表示法」，又称为渐进符号，是用于描述函数渐进行为的数学符号

>- 常数时间的操作：固定时间完成操作
> - 常见算术运算（+、-、*、/、%）等
> 

- 常见位运算（>>、>>>、<<、|、&、^）等

> - 赋值、比较、自增、自减操作等
>
> - 数组寻址
> - 非常数时间的操作：LinkedList寻址

### 时间复杂度估算

> - 等差数列求和公式：aN²+bN+c
> - 当N->无穷，常数项可忽略，只看N的最高阶，比如一个算法时间复杂度为O(N³)，另一个算法时间复杂度为O(N²)，两个算法干的是同一件事的情况下 O(N²) 优于 O(N³)

### 常见时间复杂度

> O(1)       O(logN)  O(N)      O(N*logN)
>
> O(N²)     O(N³)       ··· O(N^K)
>
> O(2^N)  O(3^N)      ··· O(k^N)
>
> O(N!)

#### 常数阶O(1)

> `O(1)`，表示该算法的执行时间（或执行时占用空间）总是为一个常量，不论输入的数据集是大是小，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如下代码，在执行的时候，它消耗的时候并`不随着某个变量的增长而增长`
> ，那么无论这类代码有多长，即使有几万几十万行，都可以用`O(1)`来表示它的时间复杂度

```java
int i 1;
int j=2;
int k i+j
```

#### 线性阶O(n)

> `O(n)`，表示一个算法的性能会随着输入数据的大小变化而线性变化，如下代码，for循环里面的代码会执行`n遍`，因此它消耗的时间是`随着n的变化而变化`的，因此这类代码都可以用`O(n)`来表示它的时间复杂度

```java
for(int i=0;i<n;i++)(
  j=i;
  j++;
}
```

#### 平方阶O(n^2)

> `O(n^2)` 表示一个算法的性能将会`随着输入数据的增长而呈现出二次增长`。最常见的就是`对输入数据进行嵌套循环`。如果`嵌套层级不断深入`的话，算法的性能将会变为立方阶`O(n^3)`，`O(n^4)`，`O(n^k)`以此类推

```java
for(x=1;1<=n;x++){
  for(i=1;i<=n;i++)(
    j=i;
    j++;
  }
}
```

#### 立方阶O(n^3)

> 同上

#### 对数阶O(logn)

> 在`while循环`里面，`每次都将 i 乘以 2`，乘完之后，`i 距离 n 就越来越近了，直到i不小于n`退出。我们试着求解一下，假设`循环次数为x，也就是说 2 的 x 次方等于 n`，则由`2^x=n得出x=logn`
> 。因此这个代码的时间复杂度为`O(logn)`

```java
i=1:
while(i<n){
    1=1*2;        
}
```

#### 线性对数阶O(nlogn)

> 线性对数阶`O(nlogn) `，就是将时间复杂度为对数阶`O(logn)`的代码循环n遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了`O(nlogn)`，如下代码

```java
for(int m=1;m<n;m++){
  i=1:
  while(i<n){
    1=1*2;
  }
}
```

#### 指数阶O(2^n)

> `O(2^n)`，表示一个算法的性能会`随着输入数据的每次增加而增大两倍`，典型的方法就是`裴波那契数列的递归计算`实现

```java
int fibonacci(int number){
   if (number <=1){
      return number;
   }
   return fibonacci(number-2)+fibonacci(number-1);
}
```

## 空间复杂度

> 空间复杂度（Space Complexity）是对一个算法在运行过程中`临时占用存储空间大小的一个量度`，同样反映的是一个趋势，一个算法所需的存储空间用f(n)表示。`S(n)=O(f(n))`，其中`n为问题的规模`
> ，`S(n)表示空间复杂度`。一个算法在计算机存储器上所占用的存储空间，包括`存储算法本身所占用的存储空间`，`算法的输入输出数据所占用的存储空间`和`算法在运行过程中临时占用的存储空间`
>
这三个方面。一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间`相对于输入数据量而言是个常数`
> ，则称此算法为`原地工作`，空间复杂度为`O(1)`。当一个算法的空间复杂度与n成线性比例关系时，可表示为`0(n)`，类比时间复杂度。
>
> - 实现一个算法，需要开辟一些空间来支持算法流程
> - 必要的或者和实现目标有关的空间都不算做额外空间
    >

- 作为输入参数的空间

> - 作为输出结果的空间
> - 只需要开辟有限几个变量：额外空间复杂度为O(1)

### 空间复杂度O(1)

> 如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)，如下代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度`S(n) = O(1)`

```java
int i 1;
int j=2;
++i;
j++;
int m i j;
```

### 空间复杂度 O(n)

> 如下代码中，第一行new了一个数组出来，这个数据占用的`大小为n`，这段代码的2-6行，虽然有循环，但`没有再分配新的空间`，因此，这段代码的空间复杂度主要看第一行即可，即 `S(n) = O(n)`

```java
int[] m = new int[n]
for(i=1;i<=n;++i){
  j=i;
  j++;
}
```

## 常见复杂度对比

### 复杂度曲线

​    ![](https://article.biliimg.com/bfs/article/2a9fd7f5a1a99731e5ee52acebff5d92592558693.jpg)

### 抽象数据结构的操作复杂度

​    ![img](https://article.biliimg.com/bfs/article/cf83835522f512cf744e0c51e0be22df592558693.jpg)

### 数组排序复杂度

​    ![img](https://article.biliimg.com/bfs/article/85059f43a412757b5a63f629e2403059592558693.jpg)

### 图操作

​    ![img](https://article.biliimg.com/bfs/article/751aaacdadbfdfab09f87307d7b64b78592558693.jpg)

### 堆操作

​    ![img](https://article.biliimg.com/bfs/article/7cd838d240f290819428d78c55f50290592558693.jpg)

## 常数项

> - 当时间复杂度相同时，通过比常数项来判断算法的优劣
>
> - 常数项对比
    >

- 放弃理论，生成随机数据进行测试（数据量*测试次数 以最终耗费时间做对比 ）

## 最优解

> - 时间复杂度尽可能的低
>
> - 尽可能优化空间

## 公共工具类

```java
package basic;

import java.util.Random;

/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/1 1:57 上午
 * @Description 公共工具类
 */
public class CommonUtils {
    public static final int[] ARR = {1, 4, 6, 2, 7, 2, 9, 8, 1, 0};

    /**
     * 替换数值
     *
     * @param arr 原数组
     * @param i   被替换元素
     * @param j   替换元素
     */
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    /**
     * 打印数组
     *
     * @param arr 数组
     */
    public static void printArray(int[] arr) {
        System.out.print("[");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i]);
            System.out.print(i < arr.length - 1 ? "," : "");
        }
        System.out.print("]\n");
    }

    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    public static int[] buildRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[maxSize];
        for (int i = 0; i < maxSize; i++) {
            arr[i] = new Random().nextInt(maxValue);
        }
        return arr;
    }

    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    private CommonUtils() {
    }
}

```

## 对数器

```java
import java.util.Arrays;

/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/1 3:22 上午
 * @Description 数组排序对数器
 */
public class DataTester {
    public static void main(String[] args) {
        int testCount = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean isSuccess = true;
        for (int i = 0; i < testCount; i++) {
            int[] arr = generateRandomArray(maxSize, maxValue);
            int[] arr1 = copyArray(arr);
            int[] arr2 = copyArray(arr);
            //需要测试的排序方法
            SelectionSort.sort(arr1);
            //用系统自带排序作为对数器和手写的排序方法做对比
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                for (int j = 0; j <arr.length ; j++) {
                    System.out.print(arr[j]+" ");
                }
                System.out.println();
                isSuccess = false;
                break;
            }
        }
        System.out.println(isSuccess?"Nice!":"Fucking fucked!");
    }

    public static int[] generateRandomArray(int maxSize, int maxValue) {
        // Math.random() ->  [0,1) 所有的小数，等概率返回一个
        // Math.random() * N -> [0,N) 所有小数，等概率返回一个
        // (int)(Math.random() * N) -> [0,N-1] 所有的整数，等概率返回一个
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }
}

```

## 异或运算

```java
int a=7;
int b=13;

//a ^ b = ?
//相同为0，不同为1
//a的二进制：0111
//b的二进制：1101
a ^ b = 10;
```

- 异或相加又称无进位相加

- 异或三大性质（技巧）

  > - 0 ^ N = N
  > - N ^ N = 0
  > - 有一批数做异或运算，同时满足交换律和结合律，得到的结果是同一个数
  >   - 偶数个1结果一定是0
  >   - 奇数个1结果一定是1

### 题记

- 两数值交换

  ```java
  int temp = 0;
  temp = a;
  a = b;
  b = temp；
    
  //以上代码可用异或代替
  1、a = a ^ b;
  //第一步：设 a=甲 ，b=乙 得：a = 甲 ^ 乙
  //将a = 甲 ^ 乙带入第二步中
  2、b = a ^ b;
  //第二步：b = 甲 ^ 乙 ^ 乙
  //由N ^ N = 0 （乙^乙=0）得：b = 甲 ^ 0 
  //由0 ^ N = N 得 b = 甲
  //将a = 甲^乙 ，b = 甲带入第二步中
  3、a = a ^ b;
  //第三步：a = 甲^乙^甲 = 甲^甲^乙 = 0^乙 = 乙
  //至此 a = 乙 ， b = 甲，完成了两数的互换
  //注意：此方法只可以用作两个不同区域的
  
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/3 12:47 上午
   * @Description 两值互换
   */
  public class TwoValueExchange {
      public static void main(String[] args) {
          twoValueExchange();
          twoValueExchangeForArray();
      }
  
      /**
       * 不用额外变量交换两个数的值
       */
      public static void twoValueExchange() {
          int a = 10;
          int b = 4;
          a = a ^ b;
          b = a ^ b;
          a = a ^ b;
          System.out.println("a=" + a);
          System.out.println("b=" + b);
      }
  
      /**
       * 不用额外变量交换数组中两个数的值
       */
      public static void twoValueExchangeForArray() {
          int[] arr = {1, 5, 3, 6};
          printArray(arr);
          //交换1、3位置的值
          arr[1] = arr[1] ^ arr[3];
          arr[3] = arr[1] ^ arr[3];
          arr[1] = arr[1] ^ arr[3];
          printArray(arr);
      }
    
     public static void printArray(int[] arr) {
          for (int i = 0; i < arr.length; i++) {
              System.out.print(arr[i] + " ");
          }
          System.out.println();
      }
  }
  ```

- 怎么把一个int类型的数，提取出二进制中最右侧的1来

  ```java
  // 运用 a & (-a) 技巧
  //设：a = 01101110010000
  //第一步：对a取反
  //得：~a = 10010001101111
  //根据 -a = ~a+1
  //得：-a = 10010001110000
  // a & (-a) = 00000000010000
  ```

- 找数

  - 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数？
  - 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数

  ```java
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/2 10:10 下午
   * @Description
   */
  public class EvenTimesOddTimes {
      public static void main(String[] args) {
          findOneKindOddNum();
          findTwoKindsOddNum();
      }
  
      //一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数？
      //利用性质三：
      // 有一批数做异或运算，同时满足交换律和结合律，得到的结果是同一个数
      // 偶数个1结果一定是0
      // 奇数个1结果一定是1
      public static void findOneKindOddNum() {
          int[] arr = {7, 4, 5, 7, 6, 7, 4, 5, 6};
          int exclusiveOr = 0;
          for (int i = 0; i < arr.length; i++) {
              exclusiveOr ^= arr[i];
          }
          // 44  55  66  777
          // 4^4=0   5^5=0   6^6=0   7^7=0  最终三个7消掉两个剩一个7直接返回
          System.out.println(exclusiveOr);
      }
  
      //一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数
      public static void findTwoKindsOddNum() {
          int[] arr = {7, 4, 5, 7, 6, 7, 5, 6};
          int exclusiveOr = 0;
          for (int i = 0; i < arr.length; i++) {
              exclusiveOr ^= arr[i];
          }
          //利用 -a = ~a+1 提取最右边的1
          int oneRight = exclusiveOr & (-exclusiveOr);
          int exclusiveOr2 = 0;
          for (int i = 0; i < arr.length; i++) {
              //4:0100   5:0101  6:0110  7:0111
              //只将最右边为1的数参与异或运算，与运算性质是只有两个位上都是1结果才为1，所以两个数与运算结果!=0的时候必然							 是两种数中的其中一个
              if ((arr[i] & oneRight) != 0) {
                  exclusiveOr2 ^= arr[i];
              }
          }
          //既然已经得到两种数中的其中一种，那么另外一种就直接用 exclusiveOr ^ exclusiveOr2 即可得出
          System.out.println(exclusiveOr2 + " , " + (exclusiveOr ^ exclusiveOr2));
      }
  }
  
  ```

- 一个数组中有一种数出现K次，其他数都出现了M次,已知M > 1，K < M，找到出现了K次的数,要求额外空间复杂度O(1)，时间复杂度O(N)

  ```java
  import java.util.HashMap;
  import java.util.HashSet;
  
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/3 3:08 上午
   * @Description
   */
  public class KM {
      public static void main(String[] args) {
          int kinds = 5;
          //设置需要生成几种数，至少两种数
          int maxValue = 100;
          int testTimes = 100000;
          for (int i = 0; i < testTimes; i++) {
              //-----------------------------------
              //以下代码保证了始终满足k<m条件
              int a = (int) (Math.random() * 9 + 1);
              int b = (int) (Math.random() * 9 + 1);
              int k = Math.min(a, b);
              int m = Math.max(a, b);
              if (k == m) {
                  m++;
              }
              //-----------------------------------
              int numKinds = (int) (Math.random() * kinds) + 2;
              int[] arr = randomArray(numKinds, maxValue, k, m);
              int res1 = test(arr, k);
              int res2 = findKTimesNum(arr, k, m);
              if (res1 != res2) {
                  System.out.println("出错了! " + res2);
              }
          }
          System.out.println("Nice!");
      }
  
      /**
       * 随机生成一个符合题意的数组
       *
       * @param maxValue
       * @param k
       * @param m
       * @return
       */
      public static int[] randomArray(int numKinds, int maxValue, int k, int m) {
          //首先设置一个数往数组里塞k次
          int kNum = randomNum(maxValue);
          //由k , m ，以及生成几种数决定数组长度
          // k+(numKinds-1)*m
          int[] arr = new int[k + (numKinds - 1) * m];
          int i = 0;
          for (; i < k; i++) {
              arr[i] = kNum;
          }
          //第一种数添加完成后减少一种数
          numKinds--;
          //生成的数要不能重复，所以建立hash表来记录已经存在的数
          HashSet<Integer> set = new HashSet<>();
          set.add(kNum);
          while (numKinds != 0) {
              int currNum = 0;
              do {
                  //如果hash表已经存在生成的数就重新生成;
                  currNum = randomNum(maxValue);
              } while (set.contains(currNum));
              set.add(currNum);
              numKinds--;
              //填充m个
              for (int j = 0; j < m; j++) {
                  //接着i的位置往后填充
                  arr[i++] = currNum;
              }
          }
          return upset(arr);
      }
  
  
      /**
       * 将规律的数组打乱
       *
       * @param arr
       * @return
       */
      public static int[] upset(int[] arr) {
          for (int i = 0; i < arr.length; i++) {
              int j = (int) (Math.random() * arr.length);
              int temp = arr[i];
              arr[i] = arr[j];
              arr[j] = temp;
          }
          return arr;
      }
  
      /**
       * 随机生成一个 -num ~ num的数
       *
       * @param range
       * @return
       */
      public static int randomNum(int range) {
          return (int) (Math.random() * range + 1) - (int) (Math.random() * range + 1);
      }
  
  
      /**
       * 寻找出现k次的数
       *
       * @param arr
       * @param m
       * @return
       */
      public static int findKTimesNum(int[] arr, int k, int m) {
          //设k=3;M=5  满足M > 1，K < M
          int[] initArr = new int[32];
          for (int num : arr) {
              for (int j = 0; j < initArr.length; j++) {
                  //&1的含义：j=0 时，num=0011 ，0011 & 1 = 1 initArr[0]+=1 在initArr[0]这个位置上记录一次
                  //j = 1 时，num >> 1 = 0001 ，0001 & 1 = 1 initArr[1]+=1 initArr[1]记录一次
                  //j = 2 时，num >> 2 = 0000 , 0000 & 1 = 0 initArr[1]+=0 相当于initArr[2]位置不记录
                  //以此类推，相当于从最低位到最高位挨个记录对应位置为1的次数
                  initArr[j] += (num >> j) & 1;
              }
          }
  
          //new一个32位int类型变量，遍历记录完各个数出现次数的initArr数组,用每个位上的次数对K和M取模，结果为1的说明这个        					 数在第i位上为1
          //逐位往new的变量里面设置值，最终得到一个数
          int result = 0;
          for (int i = 0; i < initArr.length; i++) {
              if (initArr[i] % m != 0) {
                  //在第几位上有1就将result的第几位设置成1
                  // 如：第2位上有1时 1(0001)<<2 = 0100 ；0100 | result(0000) = 0100
                  //    第3位上有1时 1(0001)<<3 = 1000 ；1000 | result(0100) = 1100
                  // 得到最终result为1100 (此结果为举例结果，非题解)
                  result |= (1 << i);
              }
          }
          return result;
      }
  
      /**
       * 对数器遍历计数法 百分百正确的结果
       *
       * @param arr
       * @param k
       * @return
       */
      public static int test(int[] arr, int k) {
          HashMap<Integer, Integer> map = new HashMap<>();
          for (int num : arr) {
              if (map.containsKey(num)) {
                  map.put(num, map.get(num) + 1);
              } else {
                  map.put(num, 1);
              }
          }
          for (int num : map.keySet()) {
              if (map.get(num) == k) {
                  return num;
              }
          }
          return -1;
      }
  }
  ```
  
- 一个数组中有一种数出现K次，其他数都出现了M次,已知M > 1，K < M，找到出现了K次的数,并且当这个数没有出现K次的时候返回-1要求额外空间复杂度O(1)，时间复杂度O(N)

  ```java
  //findKTimesNum方法改写
  public static int findKTimesNum(int[] arr, int k, int m) {
    //设k=3;M=5  满足M > 1，K < M
    int[] initArr = new int[32];
    for (int num : arr) {
      for (int j = 0; j < initArr.length; j++) {
        //&1的含义：j=0 时，num=0011 ，0011 & 1 = 1 initArr[0]+=1 在initArr[0]这个位置上记录一次
        //j = 1 时，num >> 1 = 0001 ，0001 & 1 = 1 initArr[1]+=1 initArr[1]记录一次
        //j = 2 时，num >> 2 = 0000 , 0000 & 1 = 0 initArr[1]+=0 相当于initArr[2]位置不记录
        //以此类推，相当于从最低位到最高位挨个记录对应位置为1的次数
        initArr[j] += (num >> j) & 1;
      }
    }
  
    //new一个32位int类型变量，遍历记录完各个数出现次数的initArr数组,用每个位上的次数对K和M取模，结果为1的说明这个数在第i位上为1
    //逐位往new的变量里面设置值，最终得到一个数
    int result = 0;
    for (int i = 0; i < initArr.length; i++) {
      if (initArr[i] % m == 0) {
        continue;
      }
      if (initArr[i] % m == k) {
        result |= (1 << i);
      } else {
        result = -1;
      }
    }
  
    //解决0没有出现k次的情况
    if (result==0){
      int count = 0;
      for (int num:arr) {
        if (num==0){
          count++;
        }
      }
      if (count!=k){
        return -1;
      }
    }
    return result;
  }
  
  
  
  //randomArray方法改写
  public static int[] randomArray(int numKinds, int maxValue, int k, int m) {
    //首先设置一个数往数组里塞k次
    int kNum = randomNum(maxValue);
  
    //使生成k次的几率为50%，50%几率随机生成一个比m小的数;
    int times = Math.random()<0.5?k: (int) ((Math.random() * (m - 1)) + 1);
    int[] arr = new int[times + (numKinds - 1) * m];
    int i = 0;
    for (; i < times; i++) {
      arr[i] = kNum;
    }
  
    //第一种数添加完成后减少一种数
    numKinds--;
    //生成的数要不能重复，所以建立hash表来记录已经存在的数
    HashSet<Integer> set = new HashSet<>();
    set.add(kNum);
    while (numKinds != 0) {
      int currNum = 0;
      do {
        //如果hash表已经存在生成的数就重新生成;
        currNum = randomNum(maxValue);
      } while (set.contains(currNum));
      set.add(currNum);
      numKinds--;
      //填充m个
      for (int j = 0; j < m; j++) {
        //接着i的位置往后填充
        arr[i++] = currNum;
      }
    }
    return upset(arr);
  }
  
  
  //对数器改写
  public static void main(String[] args) {
    int kinds = 5;
    //设置需要生成几种数，至少两种数
    int maxValue = 100;
    int testTimes= 100000;
  
    for (int i = 0; i < testTimes; i++) {
      //-----------------------------------
      //以下代码保证了始终满足k<m条件
      int a = (int) (Math.random() * 9 + 1);
      int b = (int) (Math.random() * 9 + 1);
      int k = Math.min(a, b);
      int m = Math.max(a, b);
      if (k == m) {
        m++;
      }
      //-----------------------------------
      int numKinds = (int) (Math.random() * kinds) + 2;
      int[] arr = randomArray(numKinds, maxValue, k, m);
      int res1 = test(arr, k);
      int res2 = findKTimesNum(arr, k, m);
  
      if (res1 != res2) {
        System.out.println("出错了! "+res1 +" "+ res2);
      }
    }
    System.out.println("Nice!");
  }
  ```
  
  

## 基础数据结构

### 链表

#### 单向链表

#### ![image-20211208204231073](https://article.biliimg.com/bfs/article/08baf2536d0f6968794ae77f742f6cf7dbe22392.png)

##### 节点结构

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/5 9:59 上午
 * @Description 单向链表节点结构
 */
public class Node<T> {
    public T value;
    public Node<T> next;

    public Node(T value) {
        this.value = value;
    }
}
```

##### 题记

###### 单链表反转

- 思路图解

###### ![image-20211213030503316](https://article.biliimg.com/bfs/article/1ee4c9b56b024a4315b7d5a1b1f143d5ae7043dd.png)

- 关键代码

  ```java
  //a -> b -> c -> null
  //null <- a <- b <- c
  public static Node reverse(Node head) {
    Node pre = null;
    Node next = null;
    while (head != null) {
      //提前记录next节点
      next = head.next;
      //将头结点的下一个节点指向Pre
      head.next = pre;
      //pre移动到当前头节点位置
      pre=head;
      //头结点移动到提前记录的next位置
      head=next;
    }
    //当head为null时说明已经到头了,此时应该返回pre所在位置的节点作为头结点
    return pre;
  }
  ```
  
  

####  

#### 双向链表

#### <img src="https://article.biliimg.com/bfs/article/a88061a87d775db4ac693b7d9fe5a6372249e6c6.png" alt="image-20211208203724483" style="zoom:100%;" />

##### 节点结构

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/5 10:35 上午
 * @Description
 */
public class DoubleNode<T> {
    public T value;
    public DoubleNode<T> pre;
    public DoubleNode<T> next;

    public DoubleNode(T value) {
        this.value = value;
    }
}
```

##### 题记

###### 双向链表反转 

- 思路图解

  ![image-20211213030331079](https://article.biliimg.com/bfs/article/e23d0a0e8b486d8e65a38d102dedd72d4165a9b3.png)

- 关键代码

  ```java
  public static DoubleNode<Integer> reverse(DoubleNode<Integer> head) {
    DoubleNode<Integer> pre = null;
    DoubleNode<Integer> next = null;
    while (head != null) {
  		//首先记录next节点
      next = head.next;
      //将当前头节点的下一个节点指向当前pre所在的地址
      head.next = pre;
      //将当前头结点的上一个节点指向原来next的地址
      head.last = next;
      //将pre标志移动到当前头的位置
      pre = head;
      //将next变为头结点
      head = next;
    }
    //当头结点到达Null的时候说明pre是最后一个有效头节点
    return pre;
  }
  ```

###### K个节点的组内逆序调整

>   - 给定一个单链表的头节点head，和一个正数k，实现k个节点的小组内部逆序，如果最后一组不够k个就不调整
>
>     - 例子: 调整前：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8，k = 3
>
>       ​		  调整后：3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8

- 思路图解

  ![image-20211218212040853](https://article.biliimg.com/bfs/article/b25bfcc2c554827e34406b9fcc3c45aebaa3eebb.png)

- 关键代码

  ```java
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/16 8:34 下午
   * @Description Definition for singly-linked list.
   * public class ListNode {
   * int val;
   * ListNode next;
   * ListNode() {}
   * ListNode(int val) { this.val = val; }
   * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
   * }
   * 力扣原题：https://leetcode-cn.com/problems/reverse-nodes-in-k-group/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china
   */
  public class ReverseKGroup<T> {
      public ListNode reverseKGroup(ListNode head, int k) {
          ListNode start = head;
          ListNode groupEnd = findGroupEnd(start, k);
          //凑不够一组直接返回当前头节点
          if (groupEnd == null) {
              return head;
          }
          //第一组满足K个
          head = groupEnd;
          reverse(start, groupEnd);
          //上一组的最后一个节点（其实就是上一组的开始节点，经过反转后成为最后一个节点）
          ListNode lastEnd = start;
          //当上一组的最后一个节点不指向Null的时候（如果最后没凑够一组也是会返回Null的）
          while (lastEnd.next != null) {
              //将上一组最后一个节点的下一个节点设置为下一组的开始节点
              start = lastEnd.next;
              groupEnd = findGroupEnd(start, k);
              if (groupEnd == null) {
                  return head;
              }
              reverse(start, groupEnd);
              //上一组反转后的最后一个节点指向这一组的结束节点
              lastEnd.next = groupEnd;
              //将下一组的开始节点设置为反转后的最后一个节点
              lastEnd = start;
          }
          return head;
      }
  
      /**
       * 组内反转
       *
       * @param start
       * @param groupEnd
       * @return
       */
      public void reverse(ListNode start, ListNode groupEnd) {
          ListNode pre = null;
          ListNode curr = start;
          //代名词为：本组反转操作的最后标志位，实际为下一组的开始节点
          ListNode operationEnd = groupEnd.next;
          //如果Curr标志位跳到操作终止节点代表本组反转已经结束
          while (curr != operationEnd) {
              ListNode next = curr.next;
              curr.next = pre;
              pre = curr;
              curr = next;
          }
          //本组的开始节点(反转后应该是最后一个节点)，指向下一组的开始节点
          start.next = operationEnd;
      }
  
      /**
       * 找每组最后一个节点
       *
       * @param start
       * @param k
       * @return
       */
      public ListNode findGroupEnd(ListNode start, int k) {
          while (--k != 0 && start != null) {
              start = start.next;
          }
          return start;
      }
  
  
      public class ListNode {
          int val;
          ListNode next;
  
          ListNode() {
          }
  
          ListNode(int val) {
              this.val = val;
          }
  
          ListNode(int val, ListNode next) {
              this.val = val;
              this.next = next;
          }
      }
  }
  
  ```

###### 两个链表相加

> 给定两个链表的头节点head1和head2，认为从左到右是某个数字从低位到高位，返回相加之后的链表
>
> - 例子     4 -> 3 -> 6 -> 9        3 -> 5 -> 4
>
>   返回     7 -> 8 -> 0 -> 0 -> 1
>
>   解释     9634 + 453 = 10087

- 思路图解

  ![image-20211222014356479](https://article.biliimg.com/bfs/article/5b19316cbcdba92f65e5efb6e31161a07a519276.png)

- 关键代码

  ```java
  //长短链表题
  //共分为三阶段：
  //一阶段：长链表有，短链表有
  //二阶段：长链表有，短链表无
  //三阶段：长链表无，短链表无
  
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/20 10:57 下午
   * @Description 两链表相加
   * @leetcode：https://leetcode.com/problems/add-two-numbers/
   */
  public class AddTwoNumbers {
      public ListNode addTwoNumbers(ListNode head1, ListNode head2) {
          int len1 = calcLength(head1);
          int len2 = calcLength(head2);
          ListNode longNode = len1 >= len2 ? head1 : head2;
          ListNode shortNode = longNode == head1 ? head2 : head1;
          ListNode currL = longNode;
          ListNode currS = shortNode;
          ListNode last = null;
          int carry = 0;
          int nodeSum = 0;
          //一阶段：长短链表都有的情况 直接判断短链表是否为NULL得知是否一阶段结束
          while (currS != null) {
              nodeSum = currL.val + currS.val + carry;
              currL.val = nodeSum % 10;
              carry = nodeSum / 10;
              last = currL;
              currL = currL.next;
              currS = currS.next;
          }
  
          //二阶段，长链表有，短链表无
          while (currL != null) {
              nodeSum = currL.val + carry;
              currL.val = nodeSum % 10;
              carry = nodeSum / 10;
              last = currL;
              currL = currL.next;
          }
  
          //三阶段：长短链表都无，校验进位信息决定是否补新节点
          if (carry != 0) {
              last.next = new ListNode(1);
          }
          return null;
      }
  
      /**
       * 计算链表长度
       *
       * @param node
       * @return
       */
      public int calcLength(ListNode node) {
          int length = 0;
          while (node != null) {
              length++;
              node = node.next;
          }
          return length;
      }
  
      public class ListNode {
          int val;
          ListNode next;
  
          ListNode() {
          }
  
          ListNode(int val) {
              this.val = val;
          }
  
          ListNode(int val, ListNode next) {
              this.val = val;
              this.next = next;
          }
      }
  }
  ```

  

###### 两个有序链表的合并

- 思路图解

  ![image-20211225114944761](https://article.biliimg.com/bfs/article/0e3a7282524d7bfa792a1fddd0188cbc1e6af2db.png)

- 关键代码

  ```java
  /**
   * @author Rhys.Ni
   * @version 1.0
   * @date 2021/12/22 8:35 下午
   * @Description 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
   * @leetcode：https://leetcode-cn.com/problems/merge-two-sorted-lists/
   */
  public class MergeTwoLists {
      public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
          if (list1 == null || list2 == null) {
              return list1 == null ? list2 : list1;
          }
  
          //找到最小的作为头节点（升序链表）
          ListNode head = list1.val <= list2.val ? list1 : list2;
          ListNode pre = head;
          ListNode curr1 = head.next;
          ListNode curr2 = head == list1 ? list2 : list1;
          //两链表都有节点
          while (curr1 != null && curr2 != null) {
              if (curr1.val <= curr2.val) {
                  pre.next = curr1;
                  curr1 = curr1.next;
              } else {
                  pre.next = curr2;
                  curr2 = curr2.next;
              }
              pre = pre.next;
          }
          //仅剩一个链表有节点
          pre.next = curr1 == null ? curr2 : curr1;
          return head;
      }
  
  
      public class ListNode {
          int val;
          ListNode next;
  
          ListNode() {
          }
  
          ListNode(int val) {
              this.val = val;
          }
  
          ListNode(int val, ListNode next) {
              this.val = val;
              this.next = next;
          }
      }
  }
  ```
  
  

## 栈

- 数据先进后出（子弹匣）

### 手写栈

### ![image-20211209030917929](https://article.biliimg.com/bfs/article/e7d844430f30781b705dffb116a1db29e570d16c.png)

#### 单链表实现

##### 思路图解

![image-20211213030758613](https://article.biliimg.com/bfs/article/1abca091465ab701f3a2244758b35846997aa956.png)

##### 关键代码

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/9 2:45 上午
 * @Description
 */
public class MyStack<T> {
    private Node<T> head;
    private int size;

    public int size() {
        return this.size;
    }

    public Boolean isEmpty() {
        return size == 0;
    }

    /**
     * 压栈
     * @param value
     */
    public void push(T value) {
        //遵循队列先进后出
        //从头节点开始弹出，符合队列先进后出机制
        Node<T> currNode = new Node<>(value);
        if (head != null) {
            currNode.next = head;
        }
        head = currNode;
        size++;
    }

    /**
     * 弹栈
     * @return
     */
    public T pop() {
        T val = null;
        if (head != null) {
            val = head.value;
            head = head.next;
            size--;
        }
        return val;
    }

    /**
     * 查看栈顶值
     * @return
     */
    public T peek() {
        return head == null ? null : head.value;
    }
}

```

- 双向链表实现

  ```java
  
  ```

- 数组实现

  ```java
  
  ```

### 题记

- 实现一个特殊的栈，在基本工能的基础上，再实现返回栈中最小元素的功能

  - pop、push、getMin操作的时间复杂度都是O(1)
  - 设计的栈类型可以使用现成的栈结构

  ```java
  //建两个栈，一个数据栈，一个最小值栈，每往数据栈里压一个值，同步往最小值栈里压一个值
  //最小值呀栈的情况为：当最小值栈为空的时候，同步压数据栈相同的数，当最小值栈里有内容的时候
  //数据栈当前压栈的值跟最小值栈里栈顶的值比较，如果比最小值栈顶值小就同步压入当前数据栈栈顶的值，
  //如果比最小值栈顶大就重复压入当前最小值栈顶的值
  ```

  



## 队列

- 数据先进先出（排队）

### 手写队列

#### 主要功能

![image-20211209030950177](https://article.biliimg.com/bfs/article/f65975718a6258df3b5fb7be7b62c80e04fcf2ee.png)

#### 单链表实现

##### 思路图解

![image-20211213221518395](https://article.biliimg.com/bfs/article/fcf407dccaab1c1a44ad1ae10c288bab45117888.png)

##### 关键代码

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/9 12:05 上午
 * @Description
 */
public class MyQueue<T> {
    private Node<T> head;
    private Node<T> tail;
    private int size;


    public int size() {
        return this.size;
    }

    public Boolean isEmpty() {
        return size == 0;
    }

    public void offer(T value) {
        //遵循队列先进先出
        //从头节点开始弹出，符合队列先进先出机制
        Node<T> currNode = new Node<>(value);
        if (tail == null) {
            head = currNode;
            tail = currNode;
        } else {
            tail.next = currNode;
            tail = currNode;
        }
        size++;
    }

    public T poll() {
        T value = null;
        if (head != null) {
            //获取当前头结点的值
            value = head.value;
            //让当前头节点的下一个节点成为新的头节点
            head = head.next;
            //每弹出一个值size同步递减
            size--;
        }
        if (head==null){
            //说明没有值了，保持头尾节点一致;
            tail = null;
        }
        return value;
    }

    public T peek() {
        T value = null;
        if (head != null) {
            //获取当前头结点的值
            value = head.value;
        }
        return value;
    }

    public MyQueue() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
}
```

### 手写双端队列

#### 主要功能

![image-20211213025804017](https://article.biliimg.com/bfs/article/b6799f424256ea185506b76f1b68b8f8f8eb6da1.png)

#### 思路图解

![image-20211213221552527](https://article.biliimg.com/bfs/article/68f719bd6947787938aca4b0017366070db8302f.png)

#### 关键代码

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2021/12/13 1:34 上午
 * @Description
 */
public class MyDeque<T> {
    private DoubleNode<T> head;
    private DoubleNode<T> tail;
    private int size;

    public void pushHead(T value) {
        DoubleNode<T> curr = new DoubleNode<>(value);
        if (head == null) {
            head = curr;
            tail = curr;
        } else {
            head.last = curr;
            curr.next = head;
            head = curr;
        }
        size++;
    }

    public void pushTail(T value) {
        DoubleNode<T> curr = new DoubleNode<>(value);
        if (head == null) {
            head = curr;
            tail = curr;
        } else {
            tail.next = curr;
            curr.last = tail;
            tail = curr;
        }
        size++;
    }

    public T pollHead() {
        T value = null;
        if (head == null) {
            return value;
        }
        value = head.value;
        if (head == tail) {
            head = null;
            tail = null;
        } else {
            head = head.next;
            head.last = null;
        }
        size--;
        return value;
    }

    public T pollTail() {
        T value = null;
        if (tail == null) {
            return value;
        }
        value = tail.value;
        if (tail == head) {
            tail = null;
            head = null;
        } else {
            tail = tail.last;
            tail.next = null;
        }
        size--;
        return value;
    }

    public T peekHead() {
        T value = null;
        if (!isEmpty()) {
            value = head.value;
        }
        return value;
    }

    public T peekTail() {
        T value = null;
        if (!isEmpty()) {
            value = tail.value;
        }
        return value;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return size;
    }

    public MyDeque() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
}

```

### 题记

- 如何用栈结构实现队列结构

  ```java
  //由于栈先进后出，队列先进先出，所以需要两个栈来拼出一个队列，先压满第一个栈，然后逐个弹栈往第二个栈里压，压完第二个栈就相当于出栈顺序跟队列保持一致了，相当于将第一个栈里的数据进行了一个反转
  //push栈没倒完数据。pop栈不能取数据
  //pop栈没取完，push栈不能倒数据
  ```

- 如何用队列结构实现栈结构

  ```java
  //由于队列先进先出 栈先进后出，每次像栈那样去取最顶（后）的值，所以建两个队列，要去1队列的最后进入的值时，把这个值前面的所有值全部pop到队列2，如果要在队列2取新进入的值，则将队列2要取的值前面所有值重新pop到队列1，只留要取的那个值，这样来回pop 就可以想栈那样push想要的值 
  ```

## 递归

- 任何递归都可以转换为非递归 

### 系统栈

```java


```

### Master公式

- 形如 T(N) = a*T(N/b)+O(N^d) 其中的a、b、d都是常数的递归函数，可以直接通过Master公式来确定时间复杂度

  1、如果log(b,a) < d,复杂度为O(N^d)

  2、如果log(b,a) > d,复杂度为O(N^log(b,a))

  3、如果log(b,a) ==d,复杂度为O(N^d*logN)

  ```java
  T(N) = 2*T(N/2)+O(N); 
  a=2,b=2,d=1; log(2,2)=1==d; 
  满足log(b,a)==d,复杂度为O(N^d*logN)
  ```

- 不属于T(N) = a*T(N/b)+O(N^d) 其中的a、b、d都是常数的递归函数这种形式的复杂度计算

  ```java
  递归取最大值时先取左边2/3再取右边2/3，这种情况下就是有一部分是重合的
  此时T(N) = 2*T(N/3/2)+O(1);
  a=2,b=3/2,d=0
  复杂度为 O(N^log(3/2,2))
  ```

## Hash表(HashMap)

- 基础类型和非基础类型底层的区别
  - 基础类型根据实际情况开辟具体空间进行存储，哪怕需要开辟的空间非常大
  - 非基础类型会将引用的类型的内存地址，8字节     
- Hash表中的原生基础类型都是按值传递 (其中包括String类型)，如果是自定义的类型（非原生自带的）按引用传递

## 有序表(TreeMap)

- 有序表可用（红黑树、avl树，sb树、跳表）实现

- Java中TreeMap使用红黑树实现

- 时间复杂度为O(logN)

-  有序表比Hash表多且强大的功能

  ```java
  TreeMap<Integer,String> treeMap = new TreeMap<>();
  //最小key
  System.out.println(treeMap.firstKey());
  //最大key
  System.out.println(treeMap.lastKey());
  //<=4 查找离4最近的key
  System.out.println(treeMap.floorKey(4));
  //>=4 查找离4最近的key
  System.out.println(treeMap.ceilingKey(4));
  ```

- 有序表对非基础类型进行排序时需要自己传一个比较器定义排序规则

## 归并排序

> MergeSort：时间复杂度为O(N*logN)，时间复杂度计算如下：
>
> **假设有一个函数`f(arr,left,right)`,让这个`arr`在`left,right`区间上有序，我们要做一下几步事情**
>
> （1）先找到中点`mid`
>
> （2）让`f(arr,left,mid)`有序
>
> （3）让`f(arr,mid+1,right)`有序
>
> （4）将`f(arr,left,mid)`和`f(arr,mid+1,right)`进行`merge`
>
> 根据Master公式`T(N) = a*T(N/b)+O(N^d) `，`a`的值取决于递归操作的数量，这里面我们需要对左右两个区间分别进行递归排序因此`a=2`、`b`则对应`（2）和（3）`，因此`b=2`,那么`O(N^d)`则对应`merge`的复杂度，`merge`为`O(N)`,最终得`T(N) = a*T(N/2)+O(N)`，由`log(b,a) ==d,`得`log(2,2)=1==d，因此复杂度为O(N*logN)`

### 归并逻辑

```java

/**
 * <p>
 * <b>归并排序</b>
 * </p >
 *
 * @author : RhysNi
 * @version : v1.0
 * @date : 2023/9/18 15:28
 * @CopyRight :　<a href="https://blog.csdn.net/weixin_44977377?type=blog">倪倪N</a>
 */
public class MergeSortMain {
    public static void main(String[] args) {
        int testTime = 500_000;
        int maxSize = 100;
        int maxValue = 100;

        System.out.println("--- MergeSort test start ---");
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = CommonUtils.buildRandomArray(maxSize, maxValue);
            int[] arr2 = CommonUtils.copyArray(arr1);

            // 递归法
            MergeSortByRecursion.mergeSort(arr1);
            // 步长法
            MergeSortNonRecursion.mergeSort(arr2);

            if (!CommonUtils.isEqual(arr1, arr2)) {
                System.out.println("MergeSort test error");
                printArray(arr1);
                printArray(arr2);
            }
        }
        System.out.println("--- MergeSort test success ---");
    }


    public static void merge(int[] arr, int startIndex, int mid, int endIndex) {
        // 辅助数组用于最终合并数据，长度为起始索引到结束索引的所有元素的个数
        int[] tempArr = new int[endIndex - startIndex + 1];
        int i = 0;
        int startIndexL = startIndex;
        int startIndexR = mid + 1;

        // 越界判断，保证左右两部分都没有越界
        while (startIndexL <= mid && startIndexR <= endIndex) {
            // 通过指针移动使左右两边的元素一一比较，哪边小就取那边，相等则默认取左边（实际取哪边都一样）
            tempArr[i++] = arr[startIndexL] <= arr[startIndexR] ? arr[startIndexL++] : arr[startIndexR++];
        }

        //当左边越界,右边没越界时，放入右组元素
        while (startIndexR <= endIndex) {
            tempArr[i++] = arr[startIndexR++];
        }
        //当右边越界，左边没越界时，放入左组元素
        while (startIndexL <= mid) {
            tempArr[i++] = arr[startIndexL++];
        }

        // 将最终排序完成的数组传递给原数组
        for (int j = 0; j < tempArr.length; j++) {
            // 从最新的起始索引开始往后
            arr[startIndex + j] = tempArr[j];
        }
    }
}
```

### 递归写法

```java
/**
 * <p>
 * <b>递归写法</b>
 * </p >
 *
 * @author : RhysNi
 * @version : v1.0
 * @date : 2023/9/18 20:10
 * @CopyRight :　<a href="https://blog.csdn.net/weixin_44977377?type=blog">倪倪N</a>
 */
public class MergeSortByRecursion {
  public static void mergeSort(int[] arr) {
    if (arr == null || arr.length < 2) {
      return;
    }
    // 对数从第一个元素到最后一个元素进行归并排序
    process(arr, 0, arr.length - 1);
  }

  private static void process(int[] arr, int startIndex, int endIndex) {
    // 开始到结束只存在一个数，默认有序，直接返回
    if (startIndex == endIndex) {
      return;
    }

    // 开始到结束存在多个元素的取中点，先对左边递归排序，再对右边递归排序，最终进行合并
    // 如果 数组长度为15，起始索引从0开始。对应最大索引为arr[14], 14>>1 = 1110 >> 1 = 0111 = 7
    // 如果 数组长度为16，起始索引从0开始。对应最大索引为arr[15], 15>>1 = 1111 >> 1 = 0111 = 7
    int mid = startIndex + ((endIndex - startIndex) >> 1);
    // 作用相同，但上面写法更安全，因为如果数组长度非常大，startIndex + endIndex 可能越界
    // int mid = (startIndex + endIndex) / 2;

    // 递归开始直到完全排序完成
    process(arr, startIndex, mid);
    process(arr, mid + 1, endIndex);
    MergeSortMain.merge(arr, startIndex, mid, endIndex);
  }
}

```

### 迭代写法

```java
/**
 * <p>
 * <b>非递归写法-计算步长</b>
 * </p >
 *
 * @author : RhysNi
 * @version : v1.0
 * @date : 2023/9/18 20:11
 * @CopyRight :　<a href="https://blog.csdn.net/weixin_44977377?type=blog">倪倪N</a>
 */
public class MergeSortNonRecursion {
  public static void mergeSort(int[] arr) {
    if (arr == null || arr.length < 2) {
      return;
    }

    // 定义一个步长，根据步长的变化控制每次参与排序的元素数量
    // 假设又数组[8，1，7，6，2]
    // step = 1 --- 则每次只有1个元素为一组参与排序，即 [8] vs [1] -- [7]vs [6] -- [2] -- 得[1,8,6,7,2]
    // step = 2 --- 则每次有2个元素为一组参与排序，即 [1,8] vs [6,7] -- [9] -- 得[1,6,7,8,2]
    // step = 4 --- 则每次有4个元素为一组参与排序，如果有凑不足4个元素为一组的就直接参与merge, 即 [1,6,7,8] vs [2] -- 得[1,2,6,7,8]
    int step = 1;

    // 最大边界为数组长度
    int endIndex = arr.length;

    // 边界判断 :
    // 有这么一种情况，假设数组最大长度是15
    // 当 step = 8 时候，左右两组得元素索引都还在边界范围内
    // 当 step = 16 时。已经比原数组长度大了。当获取arr[15]的时候就越界了，我们最大数组长度是15，对应的最大索引即为arr[14]
    // 还有一种情况 ，假设数组最大长度是16
    // 当 step = 8 时候，左右两组得元素索引都还在边界范围内
    // 当 step = 16 时, 步长和数组最大长度相等时则不用进行排序了，说明该排序的都已经排好了，右组没有多余的元素需要进行排序了。
    // 所以如果步长*2 >= 边界最大长度直接结束了
    while (step < endIndex) {
      // 左组起始索引从0开始
      int startIndexL = 0;
      while (startIndexL < endIndex) {
        // 初始化中位索引
        int midIndex = 0;
        // 确定左组边界
        if (endIndex - startIndexL >= step) {
          // 当边界索引-左组起始索引 >= 步长时:
          // 代表左组能够凑到步长数对应的元素个数或者刚好和步长相等,则可定中位索引为：左组起始索引+步长数-1
          // 假设数组长度为15：endIndex=15 -- startIndexL=0 -- step=8 -- 得endIndex-startIndexL=15 -- 因此midIndex=0+8-1=arr[7]
          // 假设数组长度为16：endIndex=16 -- startIndexL=0 -- step=16 -- 得endIndex-startIndexL=16 -- 因此midIndex=0+16-1=arr[15]
          midIndex = startIndexL + step - 1;
        } else {
          // 假设数组长度为15：endIndex=15 -- startIndexL=0 -- step=16 -- 得endIndex-startIndexL=15 -- 因此midIndex=0+16-1=arr[15]
          // 但是我们数组最大长度为15，对应的最大索引应该是arr[14]，只有15个数，凑不够16个数为一组
          // 如果使用arr[15]则会发生越界，因此我们定义midIndex为最大索引即可，有多少算多少
          midIndex = endIndex - 1;
        }

        // 如果左组长度刚好为整个数组的长度，说明该排序的都排好了，没有右组则无需排序
        if (midIndex == endIndex - 1) {
          break;
        }

        // 有右组的情况下先确定右组边界
        // 初始化右组边界
        int endIndexR = 0;
        // 因为刚才我们确定了midIndex的位置：在 startIndexL + step - 1位置上
        // - 假设数组长度为16 -- step=8：midIndex=在startIndexL + step - 1位置上=arr[7] -- endIndex - 1 - midIndex = 15-7=8
        //   因此刚好凑够一组与步长相等个数的元素，则右组边界定为中位索引+步长的值
        if (endIndex - 1 - midIndex >= step) {
          endIndexR = midIndex + step;
        } else {
          // - 假设数组长度为15 -- step=8：midIndex在startIndexL + step - 1位置上=arr[7] -- endIndex-1-midIndex = 14-7=7
          //   因此凑不够8个元素的右组，直接以最大索引作为右组最大边界
          endIndexR = endIndex - 1;
        }

        // 提供排序数组，左组开始索引，中位索引，和右组边界索引进行归并排序
        MergeSortMain.merge(arr, startIndexL, midIndex, endIndexR);

        // 如果上一组的右组边界刚好等于数组最大索引则无需继续排序
        // 如果仍然存在其他元素可进行排序，则需要将指针移动到下一组的左组起始索引位置,即endIndexR + 1的位置
        if (endIndexR == endIndex - 1) {
          break;
        } else {
          startIndexL = endIndexR + 1;
        }
      }
      // 控制步长为 2^N并且当步长 > 数组一半长度时不用继续增加步长
      // 假设数组长度15 ， endIndex / 2 = 7
      // 因此当 step=1 时候 下一次排序则需要将步长调整为 step=2...直到step=8时，此时步长超过中位索引长度，意味着本次排序完成将没有多余元素参与排序
      // 如果将步长调整为16 即step=16时，已经超过数组最大长度
      // 同理：步长==中位索引长度也是一样不需要继续调整步长
      if (step > endIndex / 2) {
        break;
      } else {
        step *= 2;
      }
    }
  }
}
```

### 面试题拓展

#### 求小和

> 给定一个数组，例如[3,5,6,3,7,8,9,2],求每个元素左侧小于当前元素的总和，要求时间复杂度`O(N*logN)`

##### 非递归实现

> -  当前数指针在`index[0]`时，`3`左侧没有比本身小的元素，故和为`0`
>- 当前数指针在`index[1]`时，`5`左侧比本身小的元素累加起来，故和为`3`
> - 当前数指针在`index[2]`时，`6`左侧比本身小的元素累加起来，故和为`8`
> - 当前数指针在`index[3]`时，`3`左侧没有比本身小的元素，故和为`0`
> - 当前数指针在`index[4]`时，`7`左侧比本身小的元素累加起来，故和为`17`
> - 当前数指针在`index[5]`时，`8`左侧比本身小的元素累加起来，故和为`24`
> - 当前数指针在`index[6]`时，`9`左侧比本身小的元素累加起来，故和为`32`
> - 当前数指针在`index[5]`时，`2`左侧没有比本身小的元素，故和为`0`
> - 最终所有和累加起来为`84`

```java
public class SmallSumCase {
    public static void main(String[] args) {
        int[] sumArr = new int[]{3, 5, 6, 3, 7, 8, 9, 2};
        int smallSum = calcu(sumArr);
        System.out.println("smallSum = " + smallSum);
    }

    private static int calcu(int[] sumArr) {
        // 不存在小和
        if (sumArr == null || sumArr.length < 2) {
            return 0;
        }

        // 初始化小和
        int smallSum = 0;

        // 每个元素挨个和右边元素进行对比
        for (int i = 0; i < sumArr.length; i++) {
            for (int j = 0; j < i; j++) {
                // 对小的元素进行累加和
                smallSum += sumArr[j] < sumArr[i] ? sumArr[j] : 0;
            }
        }
        return smallSum;
    }
}
```

> 执行结果

![image-20231124031303418](https://article.biliimg.com/bfs/article/edca9c3aab14157a59b9c06fd23f66e8592558693.png)

##### 归并排序实现

> 同样一个数组，例如[3,5,6,3,7,8,9,2]，实现思路如下：
>
> - 将数组拆分为左右两组，一直拆分到不可拆分为止
>
>   将`3,5,6,3,7,8,9,2`拆分为两组，左组`3,5,6,3`,右组`7,8,9,2`
>
> - 再将`3,5,6,3`拆分为两组，左组`3,5`,右组`6,3`
>
> - 再将`3,5`拆分为两组，左组`3`,右组`5`
>
> - 以此类推`7,8,9,2`同上
>
> 然后两组进行对比
>
> - 左组元素比右组元素小则将左组元素拷贝到新的数组，这时会产生小和，反之右组比左组小，固然先拷贝右组元素到新的数组中，但这种情况是不存在小和问题的，我们要求的是每一个元素左边比自身小的元素累加和。
>
> - 以`[3,5,6,3]`为例：
> - 左组`3`,右组`5`，对比得到 `3<5`，这时会将`3`拷贝到新的数组中，然后左组指针移动到下一个元素发现元素越界，再拷贝`5`,同时也产生了`小和问题`
> - 根据数组下标计算可得`右组有一个元素比3大`，固小和产生一个`1`，本轮`sum`=1 
>
> - 以`[6,3]`为例：
> - 左组6，右组3，对比得到`6>3`,这是会将右组`3`拷贝到新的数组中，然后移动右组指针到下一个元素发现元素越界，再将拷贝`6`，此时没有小和产生
> - 以`[3,5]|[3,6]`为例：
> - 左组`3`与右组`3`对比，两元素相等，先拷贝右边，右组指针指向下一个元素，再拷贝左边，不存在小和
> - 左组`3`与右组`6`对比，`3<6`,先拷贝`3`，移动左组指针到下一个元素`5`上，产生小和 一个`3`,本轮`sum=3` 
> - 左组`5`与右组`6`对比，`5<6`,先拷贝`5`，指针移动到下一个元素，发生越界，再拷贝右组`6`,这里存在小和，一个`5`,本轮`sum=5`
> - 最终得到`[3,3,5,6]`
> - `右组`[7,8,9,2]`以此类推得到`[2,7,8,9]
> - 最后再将[3,3,5,6]和`[2,7,8,9]`进行对比得到最终有序数组`[2,3,3,5,6,7,8,9]`
> - 再以上过程中也肯定出现了对应的小和，最终结果见代码实现

```java
public class SmallSumCase {
    public static void main(String[] args) {
        int[] sumArr = new int[]{3, 5, 6, 3, 7, 8, 9, 2};
        int Left = 0;
        int Right = sumArr.length - 1;

        int smallSum = process(sumArr, Left, Right);

        for (int i : sumArr) {
            System.out.print(i + "\t");
        }

        System.out.println("smallSum = " + smallSum);
    }

    private static int process(int[] sumArr, int startIndex, int endIndex) {
        // 开始到结束只存在一个数，不存在小和问题，不做累加操作
        if (startIndex == endIndex) {
            return 0;
        }

        // 取中位数
        int mid = startIndex + ((endIndex - startIndex) >> 1);

        // 左组区间划分
        int processLeftResult = process(sumArr, startIndex, mid);

        // 右组区间划分
        int processRightResult = process(sumArr, mid + 1, endIndex);

        // 归并排序并返回小和
        int mergeResult = merge(sumArr, startIndex, mid, endIndex);

        // 由于三个阶段都有可能产生小和，因此需要将三个阶段的小和进行累加
        return processLeftResult + processRightResult + mergeResult;
    }

    private static int merge(int[] sumArr, int startIndex, int mid, int endIndex) {
        // 定义缓存数组
        int[] tmpArr = new int[endIndex - startIndex + 1];
        // 定义缓存数组启始索引
        int tmpArrIdx = 0;

        // 定义左右组的指针所在位置
        int LMergeStartIdx = startIndex;
        int RMergeStartIdx = mid + 1;

        // 定义小和初始值
        int smallResult = 0;

        // 左右组都没发生越界
        while (LMergeStartIdx <= mid && RMergeStartIdx <= endIndex) {
            // 因为走到这里，无论什么样的数组 左右两边都已经经过层层排序都是是有序的了
            // 所以我们只需要考虑右组有多少个元素是比左组当前的元素大，就会产生多少个对应左组元素的小和
            // 那么我们只需要知道右组最后一个元素到当前右组指针位置这中间存在多少个元素即可
            // 产生小和就累加小和，没有小和产生则累加0即可
            smallResult += sumArr[LMergeStartIdx] < sumArr[RMergeStartIdx] ? (endIndex - RMergeStartIdx + 1) * sumArr[LMergeStartIdx] : 0;

            // 拷贝数组并移动指针
            tmpArr[tmpArrIdx++] = sumArr[LMergeStartIdx] < sumArr[RMergeStartIdx] ? sumArr[LMergeStartIdx++] : sumArr[RMergeStartIdx++];
        }

        // 右组越界，拷贝左组
        while (LMergeStartIdx <= mid) {
            tmpArr[tmpArrIdx++] = sumArr[LMergeStartIdx++];
        }

        // 左组越界，拷贝右组
        while (RMergeStartIdx <= endIndex) {
            tmpArr[tmpArrIdx++] = sumArr[RMergeStartIdx++];
        }

        // 将有序元素替换到原 sumArr 数组中对应位置上
        for (int i = 0; i < tmpArr.length; i++) {
            sumArr[startIndex + i] = tmpArr[i];
        }

        return smallResult;
    }
}
```

> 执行结果

![image-20231124024024070](https://article.biliimg.com/bfs/article/5f5aaf2d15b409031f4db169e6374090592558693.png)

##### 对数器验证

```java
public static void main(String[] args) {
  int testTime = 500_000;
  int maxSize = 100;
  int maxValue = 100;

  System.out.println("--- SmallSumCase test start ---");


  for (int i = 0; i < testTime; i++) {
    int[] arr1 = CommonUtils.buildRandomArray(maxSize, maxValue);
    int[] arr2 = CommonUtils.copyArray(arr1);

    if (calcu(arr1) != calcuByMergeSort(arr2)) {
      System.out.println("SmallSumCase test error");
      printArray(arr1);
      printArray(arr2);
    }
  }
  System.out.println("--- SmallSumCase test success ---");
}


// 新增方法：包装递归调用
private static int calcuByMergeSort(int[] arr2) {
  int Left = 0;
  int Right = arr2.length - 1;

  return process(arr2, Left, Right);
}
```

> 验证结果

![image-20231124032035856](https://article.biliimg.com/bfs/article/e5ee26d3d61fb8d0929421b0ccdd4d47592558693.png)

## 快速排序

### 前置知识引入案例一

> 有一数组`[2,5,7,9,3,5,8,1,3]`，取数组最后一位元素作为`区分值`
>
> - 需使`<=3`的数放`区分值`的左边,`>3`的放 `区分值`的右边，并且左边区域最右边的值为`区分值对应的元素`左右两边区域元素无需有序

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2023/9/19 9:59 PM
 */
public class QuickSortBasicKnowledge {
    public static void main(String[] args) {
        int[] arr = {2, 5, 7, 9, 3, 5, 8, 1, 3};
        partitionNum(arr);
        CommonUtils.printArray(arr);
    }

    public static void partitionNum(int[] arr) {
        // 记录小于右边元素的指针位置
        int lessRightIndex = -1;

        // 当前数所在的指针位置
        int currIndex = 0;

        // 数组最右侧元素位置(区分值)
        int mostRightIndex = arr.length - 1;

        while (currIndex < arr.length) {
            // 从数组第一个元素开始挨个和后面元素进行对比，只要出现`<=区分值`的元素，
            // 即将当前指定所在位置的元素和`上一次小于区分值元素所在位置的下一个元素`进行元素交换
            if (arr[currIndex] <= arr[mostRightIndex]) {
                CommonUtils.swap(arr, ++lessRightIndex, currIndex++);
            } else {
                // 当前指针所在位置的元素比区分值大，直接将当前指针移动到下一个元素上进行下一次对比
                currIndex++;
            }
        }

    }
}
```

> 执行结果

![image-20230920003905766](https://article.biliimg.com/bfs/article/a37eae8186630998b2b92f9f619e6470592558693.png)

### 前置知识引入案例二

> 有一数组`[2,5,7,9,3,5,8,1,3]`，取数组最后一位元素作为`区分值`
>
> - 需将最终数组分为以下三部分，使`<3`的在数组左边区域（可无序）、`=3`的在数组中间部分（有序）、`>3`的在数组右边区域（可无序）

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2023/9/19 9:59 PM
 */
public class QuickSortBasicKnowledge {
  public static void main(String[] args) {
    int[] arrAdvanced = {2, 5, 7, 9, 3, 5, 8, 1, 3};
    partitionNumAdvanced(arrAdvanced);
    CommonUtils.printArray(arrAdvanced);
  }

  public static void partitionNumAdvanced(int[] arr) {

    // 当前数所在的指针位置
    int currIndex = 0;

    // 数组最右侧元素位置(区分值)
    int mostRightIndex = arr.length - 1;

    // 记录小于于区分值区域元素的指针位置
    int lessIndex = -1;

    // 记录大于区分值区域元素的指针位置
    int greaterIndex = mostRightIndex;

    // 当两边区域的交换指针没有相遇代表还没结束对比
    while (currIndex < greaterIndex) {
      // 当前位置元素小于区分值
      if (arr[currIndex] < arr[mostRightIndex]) {
        // 小于区域的直接交换位置即可
        CommonUtils.swap(arr, ++lessIndex, currIndex++);
      } else if (arr[currIndex] > arr[mostRightIndex]) {
        // 大于区域的指针从右往左移动，记录交换元素的指针位置，当前指针不动，任然指向原来位置
        // 因为交换过来的元素不知道是大是小，还需要进一步对比
        CommonUtils.swap(arr, --greaterIndex, currIndex);
      } else {
        // 因为我们要保证中间区域是等于分区值的区域元素有序，因此不用交换数据，需要交换元素的是大于和小于区分值的区域
        currIndex++;
      }
    }
    // 由于最后一个分区值一直没有动，因此还需要将这个值与`大于分区值区域的第一个元素（就是greaterIndex最后记录的位置）`做元素交换才能保证中间区域有序
    CommonUtils.swap(arr, greaterIndex, mostRightIndex);
  }
}
```

> 运行结果

![image-20230920014837190](https://article.biliimg.com/bfs/article/7d1bb985f44f523e475d7001685ce1ca592558693.png)

> 那么以上两种案例跟快排到底有什么区别呢
>
> - 上面两种案例我们只做了第一层排序，其实第二种案例才真正意义上排好了中间区域，但是左右区域的元素仍然是乱序的，而快排真正干的事情就是排好中间的然后一直不停的去拍左右两个区域的元素，直到全部有序为止
>
> 那么来看看快排的写法，大致思想与案例二中相似，多的操作就是对左右区间的元素进行排序操作

### 公共代码提取

```java
public class QuickSortByPartition {
  public static int[] partition(int[] arr, int leftIndex, int rightIndex) {
    // 由于递归调用，因此参数列表中的leftIndex和rightIndex可能每次都是不一样的
    // 当前数所在的指针位置,从分区数组的最左侧开始
    int currIndex = leftIndex;

    // 数组最右侧元素位置(区分值)，不管是对哪个分区进行排序，始终认定有效区间内的最右边元素为区分值
    int mostRightIndex = rightIndex;

    // 记录小于于区分值区域元素的指针位置
    int lessIndex = leftIndex - 1;

    // 记录大于区分值区域元素的指针位置
    int greaterIndex = mostRightIndex;

    // 当两边区域的交换指针没有相遇代表还没结束对比
    while (currIndex < greaterIndex) {
      // 当前位置元素小于区分值
      if (arr[currIndex] < arr[mostRightIndex]) {
        // 小于区域的直接交换位置即可
        CommonUtils.swap(arr, ++lessIndex, currIndex++);
      } else if (arr[currIndex] > arr[mostRightIndex]) {
        // 大于区域的指针从右往左移动，记录交换元素的指针位置，当前指针不动，任然指向原来位置
        // 因为交换过来的元素不知道是大是小，还需要进一步对比
        CommonUtils.swap(arr, --greaterIndex, currIndex);
      } else {
        // 因为我们要保证中间区域是等于分区值的区域元素有序，因此不用交换数据，需要交换元素的是大于和小于区分值的区域
        currIndex++;
      }
    }
    // 由于最后一个分区值一直没有动，因此还需要将这个值与`大于分区值区域的第一个元素（就是greaterIndex最后记录的位置）`做元素交换才能保证中间区域有序
    CommonUtils.swap(arr, greaterIndex, mostRightIndex);
    return new int[]{++lessIndex, greaterIndex};
  }
}
```

### 栈实现

> 我们需要新建一个实体用来接收每次分区返回的边界索引

```java
public class Job {
  private int leftIndex;
  private int rightIndex;

  public Job(int leftIndex, int rightIndex) {
    this.leftIndex = leftIndex;
    this.rightIndex = rightIndex;
  }

  public int getLeftIndex() {
    return leftIndex;
  }


  public int getRightIndex() {
    return rightIndex;
  }
}
```

> 具体实现

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2023/9/19 9:59 PM
 */
public class QuickSortByPartition {
  public static void quickSortNonRecursion(int[] arr) {
    if (arr != null && arr.length >= 2) {
      // 使用栈结构保存任务
      Stack<Job> jobs = new Stack<>();

      // 往栈里压任务
      jobs.push(Job.builder()
                .leftIndex(0)
                .rightIndex(arr.length - 1)
                .build());

      while (!jobs.isEmpty()) {
        // 只要栈中存在任务，则进行分区然后对左右区间进行判断，符合条件则将对应的区间任务压入栈中
        Job job = jobs.pop();
        int[] partition = partition(arr, job.getLeftIndex(), job.getRightIndex());

        // 返回的左边界索引其实就是中间相等元素的左边界，右边界索引则是中间相等元素的右边界
        // 左边界索引 > 当前任务的最左边界索引代表存在`小于分区值`的左区域
        if (partition[0] > job.getLeftIndex()) {
          jobs.push(Job.builder()
                    .leftIndex(job.getLeftIndex())
                    .rightIndex(partition[0] - 1)
                    .build());
        }
        // 右边界索引 < 当前任务的最右边界索引代表存在`大于分区值`的右区域
        if (partition[1] < job.getRightIndex()) {
          jobs.push(Job.builder()
                    .leftIndex(partition[1] + 1)
                    .rightIndex(job.getRightIndex())
                    .build());
        }
      }
    }
  }
}
```

### 递归实现

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2023/9/19 9:59 PM
 */
public class QuickSortByPartition {
  public static void quickSort(int[] arr) {
    if (arr != null && arr.length >= 2) {
      // 递归调用分区交换元素
      process(arr, 0, arr.length - 1);
    }
  }

  private static void process(int[] arr, int leftIndex, int rightIndex) {
    if (leftIndex < rightIndex) {
      // 获取每个阶段数组的分区范围
      int[] ints = partition(arr, leftIndex, rightIndex);
      // 递归对左边区间内数组元素进行排序
      process(arr, leftIndex, ints[0] - 1);
      // 递归对右边边区间内数组元素进行排序
      process(arr, ints[1] + 1, rightIndex);
    }
  }
}
```

### 对数器验证

> 将栈实现和递归实现的结果使用对数器随机造数进行对比最终结果

```java
/**
 * @author Rhys.Ni
 * @version 1.0
 * @date 2023/9/19 9:59 PM
 */
public class QuickSortByPartition {
  public static void main(String[] args) {

    int testTime = 500_000;
    int maxSize = 100;
    int maxValue = 100;

    System.out.println("--- QuickSort test start ---");
    for (int i = 0; i < testTime; i++) {
      int[] arr1 = CommonUtils.buildRandomArray(maxSize, maxValue);
      int[] arr2 = CommonUtils.copyArray(arr1);

      // 递归法
      quickSort(arr1);
      // 栈操作
      quickSortNonRecursion(arr2);

      if (!CommonUtils.isEqual(arr1, arr2)) {
        System.out.println("QuickSort test error");
        printArray(arr1);
        printArray(arr2);
      }
    }
    System.out.println("--- QuickSort test success ---");

  }
}
```

> 验证通过，说明最终两个实现方法得到的结果都是一致的，综上所述，这就是快排

![image-20230920033332178](https://article.biliimg.com/bfs/article/7b98fe48f764057404670a83edd3dcf6592558693.png)
